import {
  OrmWasmExports,
  WasmResource,
  loadOrmWasm,
  invokeOrmWasm,
} from "./wasm.js";
import { proxyCrud } from "./crud.js";
import { IncludeTree } from "../ui/backend.js";
import {
  CloesceAst,
  Model,
  ApiMethod,
  NO_DATA_SOURCE,
  Service,
  MediaType,
  CrudKind,
} from "../ast.js";
import { Either, InternalError } from "../common.js";
import { Orm, KeysOfType, HttpResult } from "../ui/backend.js";
import { hydrateType } from "./orm.js";

export type DependencyKey<T> = Function | (new () => T) | { name: string };

/**
 * Dependency injection container, mapping an object type name to an instance of that object.
 *
 * Comes with the WranglerEnv and Request by default.
 */
export class DependencyContainer {
  private container = new Map<string, any>();

  set<T>(key: DependencyKey<T>, instance: T) {
    this.container.set(key.name, instance);
  }

  get<T>(key: DependencyKey<T>): T | undefined {
    return this.container.get(key.name);
  }

  has<T>(key: DependencyKey<T>): boolean {
    return this.container.has(key.name);
  }
}

/**
 * Map of Plain Old Objects, Models and Services to their constructor.
 * Generated by the compiler and guaranteed to contain all CIDL definitions.
 */
export type ConstructorRegistry = Record<string, new () => any>;

/**
 * @internal
 * Singleton instance containing the CIDL, constructor registry, and wasm binary.
 * These values are guaranteed to never change throughout a workers lifetime.
 */
export class RuntimeContainer {
  private static instance: RuntimeContainer | undefined;
  private constructor(
    public readonly ast: CloesceAst,
    public readonly constructorRegistry: ConstructorRegistry,
    public readonly wasm: OrmWasmExports,
  ) {}

  static async init(ast: CloesceAst, constructorRegistry: ConstructorRegistry) {
    if (this.instance) return;
    const wasmAbi = await loadOrmWasm(ast);
    this.instance = new RuntimeContainer(ast, constructorRegistry, wasmAbi);
  }

  static get(): RuntimeContainer {
    return this.instance!;
  }

  /**
   * Disposes the singleton instance. For testing purposes only.
   */
  static dispose() {
    this.instance = undefined;
  }
}

/**
 * @internal
 * Given a request, this represents a map of each body / url  param name to
 * its actual value. Unknown, as the a request can be anything.
 */
export type RequestParamMap = Record<string, unknown>;

export type MiddlewareFn = (
  di: DependencyContainer,
) => Promise<HttpResult | void> | HttpResult | void;

/**
 * Expected states in which the router may exit.
 */
export enum RouterError {
  UnknownPrefix,
  UnknownRoute,
  UnmatchedHttpVerb,
  InstantiatedMethodMissingPrimaryKey,
  InstantiatedMethodMissingKeyParam,
  RequestMissingBody,
  RequestBodyMissingParameters,
  RequestBodyInvalidParameter,
  InstantiatedMethodMissingDataSource,
  InvalidDatabaseQuery,
  ModelNotFound,
  UncaughtException,
}

export class CloesceApp {
  public routePrefix: string = "api";

  /**
   * Initializes the Cloesce runtime with the given CIDL AST and constructor registry.
   * @param ast the generated Cloesce IDL AST
   * @param ctorReg the generated constructor registry
   * @returns A CloesceApp instance
   */
  public static async init(
    ast: CloesceAst,
    ctorReg: ConstructorRegistry,
  ): Promise<CloesceApp> {
    await RuntimeContainer.init(ast, ctorReg);
    return new CloesceApp();
  }

  private onRouteMiddleware: MiddlewareFn[] = [];

  /**
   * Registers middleware than runs on every valid route.
   *
   * Runs after a route is matched, but before services are initialized.
   *
   * @param m - The middleware function to register.
   */
  public onRoute(m: MiddlewareFn) {
    this.onRouteMiddleware.push(m);
  }

  private namespaceMiddleware: Map<Function, MiddlewareFn[]> = new Map();

  /**
   * Registers middleware for a specific namespace (Model or Service)
   *
   * Runs before request validation and method middleware, and after services are initialized.
   *
   * @param m - The middleware function to register.
   */
  public onNamespace(key: Function, m: MiddlewareFn) {
    const existing = this.namespaceMiddleware.get(key);
    if (existing) {
      existing.push(m);
      return;
    }
    this.namespaceMiddleware.set(key, [m]);
  }

  private methodMiddleware: Map<Function, Map<string, MiddlewareFn[]>> =
    new Map();

  /**
   * Registers middleware for a specific method on a namespace
   *
   * Runs after namespace middleware and request validation.
   *
   * @param key - The constructor function of the Model or Service.
   * @param method - The method name or CrudKind to register the middleware for.
   * @param m - The middleware function to register.
   */
  public onMethod<T>(
    key: Function,
    method: KeysOfType<T, (...args: any) => any> | CrudKind,
    m: MiddlewareFn,
  ) {
    let classMap = this.methodMiddleware.get(key);
    if (!classMap) {
      classMap = new Map();
      this.methodMiddleware.set(key, classMap);
    }

    let methodArray = classMap.get(method);
    if (!methodArray) {
      methodArray = [];
      classMap.set(method, methodArray);
    }

    methodArray.push(m);
  }

  private async router(
    request: Request,
    env: any,
    ast: CloesceAst,
    wasm: OrmWasmExports,
    ctorReg: ConstructorRegistry,
    di: DependencyContainer,
  ): Promise<HttpResult<unknown>> {
    // Route match
    const routeRes = matchRoute(request, ast, this.routePrefix);
    if (routeRes.isLeft()) {
      return routeRes.value;
    }
    const route = routeRes.unwrap();

    // Route middleware
    for (const m of this.onRouteMiddleware) {
      const res = await m(di);
      if (res) {
        return res;
      }
    }

    // Initialize services
    // Note: Services are in topological order
    for (const name in ast.services) {
      const serviceMeta: Service = ast.services[name];
      const serviceCtor = ctorReg[name];
      const service: any = {};

      for (const attr of serviceMeta.attributes) {
        const injected = findInjected(di, attr.inject_reference);
        service[attr.var_name] = injected;
      }

      // Inject services
      const instance = Object.assign(new serviceCtor(), service);
      if (serviceMeta.initializer) {
        const params = serviceMeta.initializer.map((param) =>
          findInjected(di, param),
        );

        const res = await instance.init(...params);
        if (res) {
          return res;
        }
      }
      di.set(serviceCtor, instance);
    }

    // Namespace middleware
    for (const m of this.namespaceMiddleware.get(ctorReg[route.namespace]) ??
      []) {
      const res = await m(di);
      if (res) {
        return res;
      }
    }

    // Request validation
    const validation = await validateRequest(
      request,
      wasm,
      ast,
      env,
      ctorReg,
      route,
    );
    if (validation.isLeft()) {
      return validation.value;
    }
    const { params, dataSource } = validation.unwrap();

    // Method middleware
    for (const m of this.methodMiddleware
      .get(ctorReg[route.namespace])
      ?.get(route.method.name) ?? []) {
      const res = await m(di);
      if (res) {
        return res;
      }
    }

    // Hydration
    const hydrated = await hydrate(di, ctorReg, route, dataSource, env);

    if (hydrated.isLeft()) {
      return hydrated.value;
    }

    // Method dispatch
    return await methodDispatch(hydrated.unwrap(), di, route, params);
  }

  /**
   * Runs the Cloesce Router, handling dependency injection, routing, validation,
   * hydration, and method dispatch.
   *
   * @param request - The incoming Request object.
   * @param env - The Wrangler environment bindings.
   *
   * @returns A Response object representing the result of the request.
   */
  public async run(request: Request, env: any): Promise<Response> {
    const { ast, constructorRegistry: ctorReg, wasm } = RuntimeContainer.get();

    // DI will always contain the WranglerEnv and Request.
    const di = new DependencyContainer();
    if (ast.wrangler_env) {
      const ctor = ctorReg[ast.wrangler_env.name];
      di.set(ctor, env);
    }
    di.set(Request, request);

    try {
      const httpResult = await this.router(
        request,
        env,
        ast,
        wasm,
        ctorReg,
        di,
      );

      // Log any 500 errors
      if (httpResult.status === 500) {
        console.error(
          "A caught error occurred in the Cloesce Router: ",
          httpResult.message,
        );
      }

      return httpResult.toResponse();
    } catch (e: any) {
      let debug: any;
      if (e instanceof Error) {
        debug = {
          name: e.name,
          message: e.message,
          stack: e.stack,
          cause: (e as any).cause,
        };
      } else {
        debug = {
          name: "NonErrorThrown",
          message: typeof e === "string" ? e : JSON.stringify(e),
          stack: undefined,
        };
      }

      const res = HttpResult.fail(500, JSON.stringify(debug));
      console.error(
        "An uncaught error occurred in the Cloesce Router: ",
        debug,
      );
      return res.toResponse();
    }
  }
}

/** @internal */
export type MatchedRoute = {
  kind: "model" | "service";
  namespace: string;
  method: ApiMethod;
  primaryKey: string | null;
  keyParams: Record<string, string>;
  model?: Model;
  service?: Service;
};

/**
 * Matches a request to an ApiInvocation
 * @param apiRoute The route from the domain to the actual API, ie https://foo.com/route/to/api => route/to/api/
 * @returns 404 or a matched route.
 */
function matchRoute(
  request: Request,
  ast: CloesceAst,
  routePrefix: string,
): Either<HttpResult, MatchedRoute> {
  const url = new URL(request.url);
  const parts = url.pathname.split("/").filter(Boolean);
  const prefix = routePrefix.split("/").filter(Boolean);

  // Error state: We expect an exact request format, and expect that the model
  // and are apart of the CIDL
  const notFound = (c: RouterError) => exit(404, c, "Unknown route");

  for (const p of prefix) {
    if (parts.shift() !== p) return notFound(RouterError.UnknownPrefix);
  }

  if (parts.length < 2) {
    return notFound(RouterError.UnknownPrefix);
  }

  // Route format: /{namespace}/...{id}/{method}
  const namespace = parts[0];
  const methodName = parts[parts.length - 1];
  const id =
    parts.length > 2
      ? parts.slice(1, parts.length - 1).map(decodeURIComponent)
      : [];

  const model = ast.models[namespace];
  if (model) {
    const method = model.methods[methodName];
    if (!method) return notFound(RouterError.UnknownRoute);

    if (request.method !== method.http_verb) {
      return notFound(RouterError.UnmatchedHttpVerb);
    }

    const hasPrimaryKey = model.primary_key !== null;
    const offset = hasPrimaryKey ? 1 : 0;
    const primaryKey = hasPrimaryKey ? (id.at(0) ?? null) : null;

    const keyParams = Object.fromEntries(
      id
        .slice(offset)
        .map((v, i) => [model.key_params[i], decodeURIComponent(v)]),
    );

    return Either.right({
      kind: "model",
      namespace,
      method,
      model,
      primaryKey,
      keyParams,
    });
  }

  const service = ast.services[namespace];
  if (service) {
    const method = service.methods[methodName];
    if (!method || id.length > 0) return notFound(RouterError.UnknownRoute);

    if (request.method !== method.http_verb) {
      return notFound(RouterError.UnmatchedHttpVerb);
    }

    return Either.right({
      kind: "service",
      namespace,
      method,
      service,
      primaryKey: null,
      keyParams: {},
    });
  }

  return notFound(RouterError.UnknownRoute);
}

/**
 * Validates the request's body/search params against a ModelMethod
 * @returns 400 or a `RequestParamMap` consisting of each parameters name mapped to its value, and
 * a data source
 */
async function validateRequest(
  request: Request,
  wasm: OrmWasmExports,
  ast: CloesceAst,
  env: any,
  ctorReg: ConstructorRegistry,
  route: MatchedRoute,
): Promise<
  Either<HttpResult, { params: RequestParamMap; dataSource: string | null }>
> {
  // Error state: any missing parameter, body, or malformed input will exit with 400.
  const invalidRequest = (c: RouterError) =>
    exit(400, c, "Invalid Request Body");

  // Validate instantiated model ids
  if (route.kind === "model" && !route.method.is_static) {
    const model = route.model!;
    if (model.primary_key !== null && route.primaryKey === null) {
      return invalidRequest(RouterError.InstantiatedMethodMissingPrimaryKey);
    }

    if (model.key_params.length !== Object.keys(route.keyParams).length) {
      return invalidRequest(RouterError.InstantiatedMethodMissingKeyParam);
    }

    for (const keyParam of model.key_params) {
      if (!(keyParam in route.keyParams)) {
        return invalidRequest(RouterError.InstantiatedMethodMissingKeyParam);
      }
    }
  }

  // Filter out injected parameters
  const requiredParams = route.method.parameters.filter(
    (p) => !(typeof p.cidl_type === "object" && "Inject" in p.cidl_type),
  );

  // Extract all method parameters from the body
  const url = new URL(request.url);
  let params: RequestParamMap = Object.fromEntries(url.searchParams.entries());
  if (route.method.http_verb !== "GET") {
    try {
      switch (route.method.parameters_media) {
        case MediaType.Json: {
          const body = await request.json();
          params = { ...params, ...body };
          break;
        }
        case MediaType.Octet: {
          // Octet streams are verified by the Cloesce compiler to have
          // one Stream type
          const streamParam = requiredParams.find(
            (p) => typeof p.cidl_type === "string" && p.cidl_type === "Stream",
          )!;

          params[streamParam.name] = request.body;
          break;
        }
        default: {
          throw new InternalError("not implemented");
        }
      }
    } catch {
      return invalidRequest(RouterError.RequestMissingBody);
    }
  }

  if (!requiredParams.every((p) => p.name in params)) {
    return invalidRequest(RouterError.RequestBodyMissingParameters);
  }

  // Validate all parameters type. Octet streams need no validation.
  if (route.method.parameters_media !== MediaType.Octet) {
    for (const p of requiredParams) {
      const validateRes = invokeOrmWasm(
        wasm.validate_type,
        [
          WasmResource.fromString(JSON.stringify(p.cidl_type), wasm),
          WasmResource.fromString(JSON.stringify(params[p.name]), wasm),
        ],
        wasm,
      );

      if (validateRes.isLeft()) {
        return invalidRequest(RouterError.RequestBodyInvalidParameter);
      }

      const hydrateRes = hydrateType(
        JSON.parse(validateRes.unwrap()),
        p.cidl_type,
        {
          ast,
          ctorReg,
          includeTree: null,
          keyParams: {},
          env,
          promises: [],
        },
      );
      if (hydrateRes) {
        params[p.name] = hydrateRes;
      }
    }
  }

  // A data source is required for instantiated model methods
  const dataSource = requiredParams
    .filter(
      (p) =>
        typeof p.cidl_type === "object" &&
        "DataSource" in p.cidl_type &&
        p.cidl_type.DataSource === route.namespace,
    )
    .map((p) => params[p.name] as string)
    .at(0);
  if (
    route.kind === "model" &&
    !route.method.is_static &&
    dataSource === undefined
  ) {
    return invalidRequest(RouterError.InstantiatedMethodMissingDataSource);
  }

  return Either.right({ params, dataSource: dataSource ?? null });
}

/**
 * Hydrates a model or service instance for method dispatch.
 * @returns 500 or the hydrated instance
 */
async function hydrate(
  di: DependencyContainer,
  ctorReg: ConstructorRegistry,
  route: MatchedRoute,
  dataSource: string | null,
  env: any,
): Promise<Either<HttpResult, any>> {
  if (route.kind === "service") {
    const ctor = ctorReg[route.namespace];
    if (route.method.is_static) {
      return Either.right(ctor);
    }

    return Either.right(di.get(ctor));
  }

  const model = route.model!;
  const modelCtor = ctorReg[model.name];

  // Static methods operate on the class itself, no hydration needed
  if (route.method.is_static) {
    return Either.right(proxyCrud(modelCtor, modelCtor, env));
  }

  const includeTree: IncludeTree<any> | null =
    dataSource === NO_DATA_SOURCE
      ? null
      : (ctorReg[model.name] as any)[dataSource!];

  const orm = Orm.fromEnv(env);

  // Error state: If some outside force tweaked the database schema, the query may fail.
  // Otherwise, this indicates a bug in the compiler or runtime.
  const malformedQuery = (e: any) =>
    exit(
      500,
      RouterError.InvalidDatabaseQuery,
      `Error in hydration query, is the database out of sync with the backend?: ${e instanceof Error ? e.message : String(e)}`,
    );

  try {
    const result = await orm.get(modelCtor, {
      id: route.primaryKey,
      includeTree,
      keyParams: route.keyParams,
    });

    // Result will only be null if the instance does not exist
    // for a D1 query.
    if (result === null) {
      return exit(
        404,
        RouterError.ModelNotFound,
        `Model instance of type ${model.name} with primary key ${route.primaryKey} not found`,
      );
    }

    return Either.right(result);
  } catch (e) {
    return malformedQuery(JSON.stringify(e));
  }
}

/**
 * Calls a method on a model given a list of parameters.
 * @returns 500 on an uncaught client error, 200 with a result body on success
 */
async function methodDispatch(
  obj: any,
  di: DependencyContainer,
  route: MatchedRoute,
  params: Record<string, unknown>,
): Promise<HttpResult<unknown>> {
  const paramArray: any[] = [];
  for (const param of route.method.parameters) {
    if (param.name in params) {
      paramArray.push(params[param.name]);
      continue;
    }

    // Assume injected parameter
    const injected = findInjected(
      di,
      (param.cidl_type as { Inject: string }).Inject,
    );
    paramArray.push(injected);
  }

  const wrapResult = (res: any): HttpResult => {
    const rt = route.method.return_type;
    const httpResult: HttpResult<unknown> =
      typeof rt === "object" && rt !== null && "HttpResult" in rt
        ? res
        : HttpResult.ok(200, res);
    return httpResult.setMediaType(route.method.return_media);
  };

  try {
    const res = await obj[route.method.name](...paramArray);
    return wrapResult(res);
  } catch (e) {
    // Error state: Client code threw an uncaught exception.
    return exit(
      500,
      RouterError.UncaughtException,
      `Uncaught exception in method dispatch: ${e instanceof Error ? e.message : String(e)}`,
    ).unwrapLeft();
  }
}

function exit(
  status: number,
  state: RouterError,
  message: string,
  debugMessage: string = "",
): Either<HttpResult<void>, never> {
  return Either.left(
    HttpResult.fail(status, `${message} (ErrorCode: ${state}${debugMessage})`),
  );
}

/**
 * Finds an injected dependency from the DI container.
 * @returns The injected dependency, or undefined if not found.
 */
function findInjected(di: DependencyContainer, key: string): any | undefined {
  const injected = di.get({ name: key });
  if (injected === undefined) {
    console.warn(
      `Unable to find injected dependency for ${key}. Leaving as undefined.`,
    );
  }
  return injected;
}

/**
 * @internal
 * Exported for testing purposes only.
 */
export const _cloesceInternal = {
  matchRoute,
  validateRequest,
  methodDispatch,
  RuntimeContainer,
};
