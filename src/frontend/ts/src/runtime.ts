import {
  D1Database,
  D1PreparedStatement,
} from "@cloudflare/workers-types/experimental/index.js";
import {
  HttpResult,
  Either,
  ModelMethod,
  left,
  CidlType,
  right,
  CloesceAst,
  isNullableType,
  Model,
  getNavigationPropertyCidlType,
  CidlIncludeTree,
} from "./common.js";
import { IncludeTree } from "./index.js";

/**
 * A map of model names to their respective constructor.
 *
 * The value accepted into the `cloesce` function is generated by the Cloesce compiler, and
 * is guaranteed to contain all model definitions.
 */
type ModelConstructorRegistry = Record<string, new () => UserDefinedModel>;

/**
 * A dependency injection container, mapping an object type name to an instance of that object.
 *
 * The value accepted into the `cloesce` function is generated by the Cloesce compiler, and is
 * guaranteed to contain all injected model method parameters.
 */
type InstanceRegistry = Map<string, any>;

/**
 * Singleton instances of the MetaCidl and Constructor Registry.
 * These values are guaranteed to never change throughout a workers lifetime.
 */
class MetaContainer {
  private static instance: MetaContainer | undefined;
  private constructor(
    public readonly ast: CloesceAst,
    public readonly constructorRegistry: ModelConstructorRegistry
  ) {}

  static init(ast: CloesceAst, constructorRegistry: ModelConstructorRegistry) {
    if (!this.instance) {
      this.instance = new MetaContainer(ast, constructorRegistry);
    }
  }

  static get(): MetaContainer {
    return this.instance!;
  }
}

/**
 * Users will create Cloesce models, which have metadata for them in the ast.
 * For TypeScript's purposes, these models can be anything. We can assume any
 * `UserDefinedModel` has been verified by the compiler.
 */
type UserDefinedModel = any;
type InstantiatedUserDefinedModel = object;

/**
 * Given a request, this represents a map of each body / url  param name to
 * its actual value. Unknown, as the a request can be anything.
 */
type RequestParamMap = Record<string, unknown>;

/**
 * Meta information on the wrangler env and db bindings
 */
interface MetaWranglerEnv {
  envName: string;
  dbName: string; // TODO: support many db's
}

/**
 * Creates model instances given a properly formatted SQL record
 * (either a foreign-key-less model or derived from a Cloesce generated view)
 * @param ctor The type of the model
 * @param records SQL records
 * @param includeTree The include tree to use when parsing the records
 * @returns
 */
export function modelsFromSql<T>(
  ctor: new () => T,
  records: Record<string, any>[],
  includeTree: IncludeTree<T> | null
): T[] {
  const { ast, constructorRegistry } = MetaContainer.get();
  return _modelsFromSql(
    ctor.name,
    ast,
    constructorRegistry,
    records,
    includeTree
  ) as T[];
}

/**
 * Cloesce entry point. Given a request, undergoes routing, validating,
 * hydrating, and method dispatch.
 * @param ast The CIDL AST
 * @param constructorRegistry A mapping of user defined class names to their respective constructor
 * @param instanceRegistry A mapping of a dependency class name to its instantiated object.
 * @param request An incoming request to the workers server
 * @param api_route The url's path to the api, e.g. api/v1/fooapi/
 * @param envMeta Meta information on the wrangler env and D1 databases
 * @returns A Response with an `HttpResult` JSON body.
 */
export async function cloesce(
  request: Request,
  ast: CloesceAst,
  constructorRegistry: ModelConstructorRegistry,
  instanceRegistry: InstanceRegistry,
  envMeta: MetaWranglerEnv,
  api_route: string
): Promise<Response> {
  MetaContainer.init(ast, constructorRegistry);
  const d1: D1Database = instanceRegistry.get(envMeta.envName)[envMeta.dbName];

  // Match the route to a model method
  const route = matchRoute(request, ast, api_route);
  if (!route.ok) {
    return toResponse(route.value);
  }
  const { method, model, id } = route.value;

  // Validate request body to the model method
  const isValidRequest = await validateRequest(request, ast, model, method, id);
  if (!isValidRequest.ok) {
    return toResponse(isValidRequest.value);
  }
  const [requestParamMap, dataSource] = isValidRequest.value;

  // Instantatiate the model
  let instance: object;
  if (method.is_static) {
    instance = constructorRegistry[model.name];
  } else {
    const successfulModel = await hydrateModel(
      ast,
      constructorRegistry,
      d1,
      model,
      id!,
      dataSource
    );

    if (!successfulModel.ok) {
      return toResponse(successfulModel.value);
    }

    instance = successfulModel.value;
  }

  // Dispatch a method on the model and return the result
  return toResponse(
    await methodDispatch(
      instance,
      instanceRegistry,
      envMeta,
      method,
      requestParamMap
    )
  );
}

/**
 * Matches a request to a method on a model.
 * @param api_route The route from the domain to the actual API, ie https://foo.com/route/to/api => route/to/api/
 * @returns 404 or a `MatchedRoute`
 */
function matchRoute(
  request: Request,
  ast: CloesceAst,
  api_route: string
): Either<HttpResult, MatchedRoute> {
  const url = new URL(request.url);

  const notFound = (e: string) =>
    left(errorState(404, `Path not found: ${e} ${url.pathname}`));

  const routeParts = url.pathname
    .slice(api_route.length)
    .split("/")
    .filter(Boolean);

  if (routeParts.length < 2) {
    return notFound("Expected /model/method or /model/:id/method");
  }

  // Attempt to extract from routeParts
  const modelName = routeParts[0];
  const methodName = routeParts[routeParts.length - 1];
  const id = routeParts.length === 3 ? routeParts[1] : null;

  const model = ast.models[modelName];
  if (!model) {
    return notFound(`Unknown model ${modelName}`);
  }

  const method = model.methods[methodName];
  if (!method) {
    return notFound(`Unknown method ${modelName}.${methodName}`);
  }

  if (request.method !== method.http_verb) {
    return notFound("Unmatched HTTP method");
  }

  return right({
    model,
    method,
    id,
  });
}

/**
 * Validates the request's body/search params against a ModelMethod
 * @returns 400 or a `RequestParamMap` consisting of each parameters name mapped to its value, and
 * a data source
 */
async function validateRequest(
  request: Request,
  ast: CloesceAst,
  model: Model,
  method: ModelMethod,
  id: string | null
): Promise<Either<HttpResult, [RequestParamMap, string | null]>> {
  // Error state: any missing parameter, body, or malformed input will exit with 400.
  const invalidRequest = (e: string) =>
    left(errorState(400, `Invalid Request Body: ${e}`));

  if (!method.is_static && id == null) {
    return invalidRequest("Id's are required for instantiated methods.");
  }

  // Filter out any injected parameters that will not be passed
  // by the query.
  const requiredParams = method.parameters.filter(
    (p) =>
      !(
        typeof p.cidl_type === "object" &&
        p.cidl_type !== null &&
        "Inject" in p.cidl_type
      )
  );

  // Extract data source
  const url = new URL(request.url);
  let dataSource = url.searchParams.get("dataSource");

  // Extract url or body parameters
  let requestBodyMap: RequestParamMap;
  if (method.http_verb === "GET") {
    requestBodyMap = Object.fromEntries(url.searchParams.entries());
  } else {
    try {
      requestBodyMap = await request.json();
    } catch {
      return invalidRequest("Could not retrieve JSON body.");
    }
  }

  // Validate data source if exists
  if (dataSource && !(dataSource in model.data_sources)) {
    return invalidRequest(`Unknown data source ${dataSource}`);
  }

  // Ensure all required params exist
  if (!requiredParams.every((p) => p.name in requestBodyMap)) {
    return invalidRequest(`Missing parameters.`);
  }

  // Validate all parameters type
  for (const p of requiredParams) {
    const value = requestBodyMap[p.name];
    if (!validateCidlType(ast, value, p.cidl_type)) {
      return invalidRequest("Invalid parameters.");
    }
  }

  return right([requestBodyMap, dataSource]);
}

/**
 * Queries D1 for a particular model's ID, then transforms the SQL column output into
 * an instance of a model using the provided include tree and metadata as a guide.
 * @returns 404 if no record was found for the provided ID
 * @returns 500 if the D1 database is not synced with Cloesce and yields an error
 * @returns The instantiated model on success
 */
async function hydrateModel(
  ast: CloesceAst,
  constructorRegistry: ModelConstructorRegistry,
  d1: D1Database,
  model: Model,
  id: string,
  dataSource: string | null
): Promise<Either<HttpResult, object>> {
  // Error state: If the D1 database has been tweaked outside of Cloesce
  // resulting in a malformed query, exit with a 500.
  const malformedQuery = (e: any) =>
    left(
      errorState(
        500,
        `Error in hydration query, is the database out of sync with the backend?: ${e instanceof Error ? e.message : String(e)}`
      )
    );

  // Error state: If no record is found for the id, return a 404
  const missingRecord = left(errorState(404, "Record not found"));

  const pk = model.primary_key.name;
  const query =
    dataSource !== null
      ? `SELECT * FROM "${model.name}.${dataSource}" WHERE "${model.name}.${pk}" = ?`
      : `SELECT * FROM "${model.name}" WHERE "${pk}" = ?`;

  // Query DB
  let records;
  try {
    records = await d1.prepare(query).bind(id).run();
    if (!records) {
      return missingRecord;
    }
    if (records.error) {
      return malformedQuery(records.error);
    }
  } catch (e) {
    return malformedQuery(e);
  }

  // Get include tree
  const includeTree: CidlIncludeTree =
    dataSource !== null ? model.data_sources[dataSource].tree : {};

  // Hydrate
  const models: object[] = _modelsFromSql(
    model.name,
    ast,
    constructorRegistry,
    records.results,
    includeTree
  );

  console.log(JSON.stringify(models));

  return right(models[0]);
}

/**
 * Calls a method on a model given a list of parameters.
 * @returns 500 on an uncaught client error, 200 with a result body on success
 */
async function methodDispatch(
  instance: InstantiatedUserDefinedModel,
  instanceRegistry: InstanceRegistry,
  envMeta: MetaWranglerEnv,
  method: ModelMethod,
  params: Record<string, unknown>
): Promise<HttpResult<unknown>> {
  // Error state: Client code ran into an uncaught exception.
  const uncaughtException = (e: any) =>
    errorState(
      500,
      `Uncaught exception in method dispatch: ${e instanceof Error ? e.message : String(e)}`
    );

  // For now, the only injected dependency is the wrangler env,
  // so we will assume that is what this is
  const paramArray = method.parameters.map((p) =>
    params[p.name] == undefined
      ? instanceRegistry.get(envMeta.envName)
      : params[p.name]
  );

  // Ensure the result is always some HttpResult
  const resultWrapper = (res: any): HttpResult<unknown> => {
    const rt = method.return_type;

    if (rt === null) {
      return { ok: true, status: 200 };
    }

    if (typeof rt === "object" && rt !== null && "HttpResult" in rt) {
      return res as HttpResult<unknown>;
    }

    return { ok: true, status: 200, data: res };
  };

  try {
    return resultWrapper(await (instance as any)[method.name](...paramArray));
  } catch (e) {
    return uncaughtException(e);
  }
}

function validateCidlType(
  ast: CloesceAst,
  value: unknown,
  cidlType: CidlType
): boolean {
  if (value === undefined) return false;

  // TODO: consequences of null checking like this? 'null' is passed in
  // as a string for GET requests...
  const nullable = isNullableType(cidlType);
  if (value == null || value === "null") return nullable;

  if (nullable) {
    cidlType = (cidlType as any).Nullable; // Unwrap the nullable type
  }

  // Handle primitive string types with switch
  if (typeof cidlType === "string") {
    switch (cidlType) {
      case "Integer":
        return Number.isInteger(Number(value));
      case "Real":
        return !Number.isNaN(Number(value));
      case "Text":
        return typeof value === "string";
      case "Blob":
        return value instanceof Blob || value instanceof ArrayBuffer;
      default:
        return false;
    }
  }

  // Handle Models
  if ("Object" in cidlType && ast.models[cidlType.Object]) {
    const model = ast.models[cidlType.Object];
    if (!model || typeof value !== "object") return false;
    const valueObj = value as Record<string, unknown>;

    // Validate attributes
    if (
      !model.attributes.every((attr) =>
        validateCidlType(ast, valueObj[attr.value.name], attr.value.cidl_type)
      )
    ) {
      return false;
    }

    // Validate navigation properties
    return model.navigation_properties.every((nav) => {
      const navValue = valueObj[nav.var_name];

      return (
        navValue == null ||
        validateCidlType(ast, navValue, getNavigationPropertyCidlType(nav))
      );
    });
  }

  // Handle Plain Old Objects
  if ("Object" in cidlType && ast.poos[cidlType.Object]) {
    const poo = ast.poos[cidlType.Object];
    if (!poo || typeof value !== "object") return false;
    const valueObj = value as Record<string, unknown>;

    // Validate attributes
    if (
      !poo.attributes.every((attr) =>
        validateCidlType(ast, valueObj[attr.name], attr.cidl_type)
      )
    ) {
      return false;
    }
  }

  if ("Array" in cidlType) {
    const arr = cidlType.Array;
    return (
      Array.isArray(value) && value.every((v) => validateCidlType(ast, v, arr))
    );
  }

  if ("HttpResult" in cidlType) {
    if (value === null) return cidlType.HttpResult === null;
    if (cidlType.HttpResult === null) return false;
    return validateCidlType(ast, value, cidlType.HttpResult);
  }

  return false;
}

/**
 * Actual implementation of sql to model mapping.
 *
 * TODO: If we don't want to write this in every language, would it be possible to create a
 * single WASM binary for this method?
 *
 * @throws generic errors if the metadata is missing some value
 */
// Main function that creates instances from SQL records
function _modelsFromSql(
  modelName: string,
  ast: CloesceAst,
  constructorRegistry: ModelConstructorRegistry,
  records: Record<string, any>[],
  includeTree: Record<string, UserDefinedModel> | null
): any[] {
  const model = ast.models[modelName];
  if (!model) return [];

  const Constructor = constructorRegistry[modelName];
  if (!Constructor) return [];

  const pkName = model.primary_key.name;
  const resultMap = new Map<any, any>();

  for (const record of records) {
    const pkValue = record[`${modelName}.${pkName}`] ?? record[pkName];
    if (pkValue == null) continue;

    let instance = resultMap.get(pkValue);

    if (!instance) {
      instance = new Constructor();
      instance[pkName] = pkValue;

      // Set scalar attributes
      for (const attr of model.attributes) {
        const attrName = attr.value.name;
        const prefixedKey = `${modelName}.${attrName}`;
        const nonPrefixedKey = attrName;

        if (prefixedKey in record) {
          instance[attrName] = record[prefixedKey];
        } else if (nonPrefixedKey in record) {
          instance[attrName] = record[nonPrefixedKey];
        }
      }

      // Initialize ALL navigation properties at root level
      // If not in include tree, initialize OneToMany and ManyToMany as empty arrays
      for (const navProp of model.navigation_properties) {
        if ("OneToMany" in navProp.kind || "ManyToMany" in navProp.kind) {
          // Always initialize OneToMany and ManyToMany as empty arrays
          instance[navProp.var_name] = [];
        }
        // OneToOne properties left as undefined unless populated
      }

      resultMap.set(pkValue, instance);
    }

    // Process navigation properties that are in the include tree
    if (includeTree) {
      processNavigationProperties(
        instance,
        model,
        modelName,
        includeTree,
        record,
        ast,
        constructorRegistry
      );
    }
  }

  return Array.from(resultMap.values());
}

function processNavigationProperties(
  instance: any,
  model: any,
  prefix: string,
  includeTree: Record<string, UserDefinedModel>,
  record: Record<string, any>,
  ast: CloesceAst,
  constructorRegistry: ModelConstructorRegistry
): void {
  for (const navProp of model.navigation_properties) {
    if (!(navProp.var_name in includeTree)) {
      continue;
    }

    const nestedModel = ast.models[navProp.model_name];
    if (!nestedModel) {
      continue;
    }

    // Extract nested model's primary key - check both prefixed and non-prefixed
    const nestedPkName = nestedModel.primary_key.name;
    const prefixedNestedPkKey = `${prefix}.${navProp.var_name}.${nestedPkName}`;
    const nonPrefixedNestedPkKey = `${navProp.var_name}.${nestedPkName}`;
    const nestedPkValue =
      record[prefixedNestedPkKey] ?? record[nonPrefixedNestedPkKey];

    if (nestedPkValue == null) {
      continue; // No nested object in this row
    }

    // Determine if this is OneToMany/ManyToMany or OneToOne
    const isOneToMany =
      "OneToMany" in navProp.kind || "ManyToMany" in navProp.kind;

    // Check if we already added this nested object (for OneToMany)
    if (isOneToMany) {
      const navArray = instance[navProp.var_name];
      const alreadyExists = navArray.some(
        (item: any) => item[nestedPkName] === nestedPkValue
      );
      if (alreadyExists) {
        continue;
      }
    } else {
      // For OneToOne, check if already set
      if (instance[navProp.var_name] != null) {
        continue;
      }
    }

    const NestedConstructor = constructorRegistry[navProp.model_name];
    if (!NestedConstructor) {
      continue;
    }

    const nestedInstance = new NestedConstructor();
    nestedInstance[nestedPkName] = nestedPkValue;

    // Assign nested scalar attributes - check both prefixed and non-prefixed
    for (const nestedAttr of nestedModel.attributes) {
      const nestedAttrName = nestedAttr.value.name;
      const prefixedKey = `${prefix}.${navProp.var_name}.${nestedAttrName}`;
      const nonPrefixedKey = `${navProp.var_name}.${nestedAttrName}`;

      // Check prefixed key first, then non-prefixed
      if (prefixedKey in record) {
        nestedInstance[nestedAttrName] = record[prefixedKey];
      } else if (nonPrefixedKey in record) {
        nestedInstance[nestedAttrName] = record[nonPrefixedKey];
      }
    }

    // Initialize ALL navigation properties on the nested instance
    // If not in include tree, initialize OneToMany and ManyToMany as empty arrays
    const nestedIncludeTree = includeTree[navProp.var_name];
    for (const nestedNavProp of nestedModel.navigation_properties) {
      const isInIncludeTree =
        nestedIncludeTree &&
        typeof nestedIncludeTree === "object" &&
        nestedNavProp.var_name in nestedIncludeTree;

      if (
        "OneToMany" in nestedNavProp.kind ||
        "ManyToMany" in nestedNavProp.kind
      ) {
        // Always initialize OneToMany and ManyToMany as arrays (empty if not in include tree)
        nestedInstance[nestedNavProp.var_name] = [];
      } else if (!isInIncludeTree) {
        // OneToOne not in include tree - leave as undefined or null
        // Will be set during recursive processing if in include tree
      }
    }

    // Recursively process nested navigation properties that are in the include tree
    if (nestedIncludeTree && typeof nestedIncludeTree === "object") {
      processNavigationProperties(
        nestedInstance,
        nestedModel,
        `${prefix}.${navProp.var_name}`,
        nestedIncludeTree,
        record,
        ast,
        constructorRegistry
      );
    }

    // Assign the nested instance based on relationship type
    if (isOneToMany) {
      instance[navProp.var_name].push(nestedInstance);
    } else {
      // OneToOne - assign directly
      instance[navProp.var_name] = nestedInstance;
    }
  }
}

function errorState(status: number, message: string): HttpResult {
  return { ok: false, status, message };
}

function toResponse(r: HttpResult): Response {
  return new Response(JSON.stringify(r), {
    status: r.status,
    headers: { "Content-Type": "application/json" },
  });
}

interface MatchedRoute {
  model: Model;
  method: ModelMethod;
  id: string | null;
}

/**
 * Each individual state of the `cloesce` function for testing purposes.
 */
export const _cloesceInternal = {
  matchRoute,
  validateRequest,
  hydrateModel,
  methodDispatch,
  _modelsFromSql,
};
