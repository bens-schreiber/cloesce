import { D1Database } from "@cloudflare/workers-types/experimental/index.js";

import { OrmWasmExports, mapSql, loadOrmWasm } from "./wasm.js";
import { CrudProxy } from "./crud.js";
import { HttpResult, IncludeTree, Orm } from "../ui/backend.js";
import { Either, KeysOfType } from "../ui/common.js";
import {
  CloesceAst,
  HttpVerb,
  Model,
  ApiMethod,
  NO_DATA_SOURCE,
  NamedTypedValue,
  Service,
  CidlType,
} from "../ast.js";
import { RuntimeValidator } from "./validator.js";

/**
 * Dependency injection container, mapping an object type name to an instance of that object.
 *
 * Comes with the WranglerEnv and Request by default.
 */
export type DependencyContainer = Map<string, any>;

/**
 * Map of Plain Old Objects, Models and Services to their constructor.
 *
 * Generated by the compiler and guaranteed to contain all CIDL definitions.
 */
export type ConstructorRegistry = Record<string, new () => any>;

/**
 * Singleton instance containing the cidl, constructor registry, and wasm binary.
 * These values are guaranteed to never change throughout a workers lifetime.
 */
export class RuntimeContainer {
  private static instance: RuntimeContainer | undefined;
  private constructor(
    public readonly ast: CloesceAst,
    public readonly constructorRegistry: ConstructorRegistry,
    public readonly wasm: OrmWasmExports,
  ) {}

  static async init(
    ast: CloesceAst,
    constructorRegistry: ConstructorRegistry,
    wasm?: WebAssembly.Instance,
  ) {
    if (this.instance) return;
    const wasmAbi = await loadOrmWasm(ast, wasm);
    this.instance = new RuntimeContainer(ast, constructorRegistry, wasmAbi);
  }

  static get(): RuntimeContainer {
    return this.instance!;
  }
}

/**
 * Meta information on the wrangler env and db bindings
 */
interface MetaWranglerEnv {
  envName: string;
  dbName: string; // TODO: support many db's
}

/**
 * Given a request, this represents a map of each body / url  param name to
 * its actual value. Unknown, as the a request can be anything.
 */
export type RequestParamMap = Record<string, unknown>;

export type MiddlewareFn = (
  request: Request,
  env: any,
  di: DependencyContainer,
) => Promise<HttpResult | void>;

export type ResultMiddlewareFn = (
  request: Request,
  env: any,
  di: DependencyContainer,
  result: HttpResult,
) => Promise<HttpResult | void>;

export class CloesceApp {
  public routePrefix: string = "api";

  private globalMiddleware: MiddlewareFn[] = [];

  /**
   * Registers global middleware which runs before any route matching.
   *
   * @param m - The middleware function to register.
   */
  public onRequest(m: MiddlewareFn) {
    this.globalMiddleware.push(m);
  }

  private resultMiddleware: ResultMiddlewareFn[] = [];

  /**
   * Registers middleware which runs after the response is generated, but before
   * it is returned to the client.
   *
   * Optionally, return a new HttpResult to short-circuit the response.
   *
   * Errors thrown in response middleware are caught and returned as a 500 response.
   *
   * Errors thrown in earlier middleware or route processing are not caught here.
   *
   * @param m - The middleware function to register.
   */
  public onResult(m: ResultMiddlewareFn) {
    this.resultMiddleware.push(m);
  }

  private namespaceMiddleware: Map<string, MiddlewareFn[]> = new Map();

  /**
   * Registers middleware for a specific namespace (being, a model or service)
   *
   * Runs before request validation and method middleware.
   *
   * @typeParam T - The namespace type
   * @param ctor - The namespace's constructor (used to derive its name).
   * @param m - The middleware function to register.
   */
  public onNamespace<T>(ctor: new () => T, m: MiddlewareFn) {
    if (this.namespaceMiddleware.has(ctor.name)) {
      this.namespaceMiddleware.get(ctor.name)!.push(m);
    } else {
      this.namespaceMiddleware.set(ctor.name, [m]);
    }
  }

  private methodMiddleware: Map<string, Map<string, MiddlewareFn[]>> =
    new Map();

  /**
   * Registers middleware for a specific method on a model.
   *
   * Runs after namespace middleware and request validation.
   *
   * @typeParam T - The model type.
   * @param ctor - The model constructor (used to derive its name).
   * @param method - The method name on the model.
   * @param m - The middleware function to register.
   */
  public onMethod<T>(
    ctor: new () => T,
    method: KeysOfType<T, (...args: any) => any>,
    m: MiddlewareFn,
  ) {
    if (!this.methodMiddleware.has(ctor.name)) {
      this.methodMiddleware.set(ctor.name, new Map());
    }

    const methods = this.methodMiddleware.get(ctor.name)!;
    if (!methods.has(method)) {
      methods.set(method, []);
    }

    methods.get(method)!.push(m);
  }

  /**
   * Router entry point. Undergoes route matching, request validation, hydration, and method dispatch.
   */
  private async cloesce(
    request: Request,
    env: any,
    ast: CloesceAst,
    ctorReg: ConstructorRegistry,
    di: DependencyContainer,
    d1: D1Database,
  ): Promise<HttpResult> {
    // Global middleware
    for (const m of this.globalMiddleware) {
      const res = await m(request, env, di);
      if (res) {
        return res;
      }
    }

    // Route match
    const routeRes = matchRoute(request, ast, this.routePrefix);
    if (routeRes.isLeft()) {
      return routeRes.value;
    }
    const { route, id } = routeRes.unwrap();

    // Model middleware
    for (const m of this.namespaceMiddleware.get(route.namespace) ?? []) {
      const res = await m(request, env, di);
      if (res) {
        return res;
      }
    }

    // Request validation
    const validation = await validateRequest(request, ast, ctorReg, route, id);
    if (validation.isLeft()) {
      return validation.value;
    }
    const { params, dataSource } = validation.unwrap();

    // Method middleware
    for (const m of this.methodMiddleware
      .get(route.namespace)
      ?.get(route.methodName) ?? []) {
      const res = await m(request, env, di);
      if (res) {
        return res;
      }
    }

    // Static, skip hydration
    if (route.isMethodStatic) {
      const instance = CrudProxy.fromCtor(d1, ctorReg[route.namespace]);

      // Method dispatch
      return await methodDispatch(instance, di, route, params);
    }

    // Hydration
    const hydrated = await route.hydrate(d1, ctorReg, id, dataSource, di);
    if (hydrated.isLeft()) {
      return hydrated.value;
    }

    // Method dispatch
    return await methodDispatch(hydrated.unwrap(), di, route, params);
  }

  /**
   * Runs the Cloesce app. Intended to be called from the generated workers code.
   */
  public async run(
    request: Request,
    env: any,
    ast: CloesceAst,
    ctorReg: ConstructorRegistry,
    envMeta: MetaWranglerEnv,
  ): Promise<Response> {
    const di: DependencyContainer = new Map();
    di.set(envMeta.envName, env);
    di.set("Request", request);

    // Note: The compiler will put services in topological order
    for (const name in ast.services) {
      const service: any = ast.services[name];

      for (const attr of service.attributes) {
        const injected = di.get(attr.injected);
        if (!injected) {
          return HttpResult.fail(
            500,
            `An injected parameter was missing from the instance registry: ${JSON.stringify(attr.injected)} (ErrorCode: ${RouterFailState.MissingDependency})`,
          ).toResponse();
        }

        service[attr.var_name] = injected;
      }

      // Inject services
      di.set(name, Object.assign(new ctorReg[name](), service));
    }

    await RuntimeContainer.init(ast, ctorReg);
    const d1: D1Database = env[envMeta.dbName]; // TODO: multiple dbs

    try {
      // Core cloesce processing
      const response = await this.cloesce(request, env, ast, ctorReg, di, d1);

      // Response middleware
      for (const m of this.resultMiddleware) {
        const res = await m(request, env, di, response);
        if (res) {
          return res.toResponse();
        }
      }

      return response.toResponse();
    } catch (e: any) {
      console.error(JSON.stringify(e));
      return HttpResult.fail(500, e.toString()).toResponse();
    }
  }
}

export enum RouterFailState {
  UnknownPrefix,
  UnknownRoute,
  UnmatchedHttpVerb,
  InstantiatedMethodMissingId,
  RequestMissingJsonBody,
  RequestBodyMissingParameters,
  RequestBodyInvalidParameter,
  InstantiatedMethodMissingDataSource,
  MissingDependency,
  InvalidDatabaseQuery,
  ModelNotFound,
  UncaughtException,
}

interface MatchedRoute {
  get verb(): HttpVerb;
  get namespace(): string;
  get isStatic(): boolean;
  get isMethodStatic(): boolean;
  get params(): NamedTypedValue[];
  get methodName(): string;
  get returnType(): CidlType;
  hydrate(
    d1: D1Database,
    ctorReg: ConstructorRegistry,
    id: string | null,
    dataSource: string | null,
    di: DependencyContainer,
  ): Promise<Either<HttpResult, CrudProxy>>;
}

export class ModelRoute implements MatchedRoute {
  constructor(
    private model: Model,
    private method: ApiMethod,
  ) {}

  get verb(): HttpVerb {
    return this.method.http_verb;
  }

  get namespace(): string {
    return this.model.name;
  }

  get isStatic(): boolean {
    return this.method.is_static;
  }

  get isMethodStatic(): boolean {
    return this.method.is_static;
  }

  get params(): NamedTypedValue[] {
    return this.method.parameters;
  }

  get methodName(): string {
    return this.method.name;
  }

  get returnType(): CidlType {
    return this.method.return_type;
  }

  async hydrate(
    d1: D1Database,
    ctorReg: ConstructorRegistry,
    id: string | null,
    dataSource: string | null,
  ): Promise<Either<HttpResult, CrudProxy>> {
    const hydratedModel = await hydrateModel(
      ctorReg,
      d1,
      this.model,
      id!, // id must exist after matchRoute
      dataSource!, // ds must exist after validateRequest
    );

    return hydratedModel.map((_) =>
      CrudProxy.fromInstance(d1, hydratedModel.value, ctorReg[this.namespace]),
    );
  }

  static from(
    ast: CloesceAst,
    modelName: string,
    methodName: string,
  ): MatchedRoute | null {
    const model = ast.models[modelName];
    if (!model) {
      return null;
    }

    const method = model.methods[methodName];
    if (!method) {
      return null;
    }

    return new ModelRoute(model, method);
  }
}

export class ServiceRoute implements MatchedRoute {
  constructor(
    private service: Service,
    private method: ApiMethod,
  ) {}

  get verb(): HttpVerb {
    return this.method.http_verb;
  }

  get namespace(): string {
    return this.service.name;
  }

  get isStatic(): boolean {
    return true;
  }

  get isMethodStatic(): boolean {
    return this.method.is_static;
  }

  get params(): NamedTypedValue[] {
    return this.method.parameters;
  }

  get methodName(): string {
    return this.method.name;
  }

  get returnType(): CidlType {
    return this.method.return_type;
  }

  /// Fetches the instance from DI
  async hydrate(
    d1: D1Database,
    ctorReg: ConstructorRegistry,
    _id: string | null,
    _dataSource: string | null,
    di: DependencyContainer,
  ): Promise<Either<HttpResult, CrudProxy>> {
    const service = di.get(this.namespace);
    if (!service) {
      return Either.left(
        HttpResult.fail(
          500,
          `An injected parameter was missing from the instance registry: ${JSON.stringify(this.namespace)} (ErrorCode: ${RouterFailState.MissingDependency})`,
        ),
      );
    }

    return Either.right(
      CrudProxy.fromInstance(d1, service, ctorReg[this.namespace]),
    );
  }

  static from(
    ast: CloesceAst,
    serviceName: string,
    methodName: string,
  ): MatchedRoute | null {
    const service = ast.services[serviceName];
    if (!service) {
      return null;
    }

    const method = service.methods[methodName];
    if (!method) {
      return null;
    }

    return new ServiceRoute(service, method);
  }
}

/**
 * Matches a request to an ApiInvocation
 * @param apiRoute The route from the domain to the actual API, ie https://foo.com/route/to/api => route/to/api/
 * @returns 404 or a matched route.
 */
function matchRoute(
  request: Request,
  ast: CloesceAst,
  routePrefix: string,
): Either<
  HttpResult,
  {
    route: MatchedRoute;
    id: string | null;
  }
> {
  const url = new URL(request.url);
  const parts = url.pathname.split("/").filter(Boolean);
  const prefix = routePrefix.split("/").filter(Boolean);

  // Error state: We expect an exact request format, and expect that the model
  // and are apart of the CIDL
  const notFound = (c: RouterFailState) =>
    Either.left(HttpResult.fail(404, `Unknown route (ErrorCode: ${c})`));

  for (const p of prefix) {
    if (parts.shift() !== p) return notFound(RouterFailState.UnknownPrefix);
  }

  if (parts.length < 2) {
    return notFound(RouterFailState.UnknownPrefix);
  }

  // Attempt to extract from routeParts
  const namespaceName = parts[0];
  const methodName = parts[parts.length - 1];
  const id = parts.length === 3 ? parts[1] : null;

  const route =
    ModelRoute.from(ast, namespaceName, methodName) ??
    ServiceRoute.from(ast, namespaceName, methodName);

  if (!route) {
    return notFound(RouterFailState.UnknownRoute);
  }

  if (request.method !== route.verb) {
    return notFound(RouterFailState.UnmatchedHttpVerb);
  }

  return Either.right({
    route,
    id,
  });
}

/**
 * Validates the request's body/search params against a ModelMethod
 * @returns 400 or a `RequestParamMap` consisting of each parameters name mapped to its value, and
 * a data source
 */
async function validateRequest(
  request: Request,
  ast: CloesceAst,
  ctorReg: ConstructorRegistry,
  route: MatchedRoute,
  id: string | null,
): Promise<
  Either<HttpResult, { params: RequestParamMap; dataSource: string | null }>
> {
  // Error state: any missing parameter, body, or malformed input will exit with 400.
  const invalidRequest = (c: RouterFailState) =>
    Either.left(HttpResult.fail(400, `Invalid Request Body (ErrorCode: ${c})`));

  if (!route.isStatic && id == null) {
    return invalidRequest(RouterFailState.InstantiatedMethodMissingId);
  }

  // Filter out any injected parameters that will not be passed
  // by the query.
  const requiredParams = route.params.filter(
    (p) => !(typeof p.cidl_type === "object" && "Inject" in p.cidl_type),
  );

  // Extract url or body parameters
  const url = new URL(request.url);
  let params: RequestParamMap = {};
  if (route.verb === "GET") {
    params = Object.fromEntries(url.searchParams.entries());
  } else {
    try {
      params = await request.json();
    } catch {
      return invalidRequest(RouterFailState.RequestMissingJsonBody);
    }
  }

  // Ensure all required params exist
  if (!requiredParams.every((p) => p.name in params)) {
    return invalidRequest(RouterFailState.RequestBodyMissingParameters);
  }

  // Validate all parameters type
  for (const p of requiredParams) {
    const res = RuntimeValidator.fromJson(
      params[p.name],
      p.cidl_type,
      ast,
      ctorReg,
    );
    if (res.isLeft()) {
      return invalidRequest(RouterFailState.RequestBodyInvalidParameter);
    }

    params[p.name] = res.unwrap();
  }

  const dataSource: string | undefined = requiredParams
    .filter(
      (p) =>
        typeof p.cidl_type === "object" &&
        "DataSource" in p.cidl_type &&
        p.cidl_type.DataSource === route.namespace,
    )
    .map((p) => params[p.name] as string)[0];

  // Data source is required for instantiated methods
  if (!route.isStatic && !dataSource) {
    return invalidRequest(RouterFailState.InstantiatedMethodMissingDataSource);
  }

  return Either.right({ params, dataSource: dataSource ?? null });
}

/**
 * Queries D1 for a particular model's ID, then transforms the SQL column output into
 * an instance of a model using the provided include tree and metadata as a guide.
 * @returns 404 if no record was found for the provided ID
 * @returns 500 if the D1 database is not synced with Cloesce and yields an error
 * @returns The instantiated model on success
 */
async function hydrateModel(
  constructorRegistry: ConstructorRegistry,
  d1: D1Database,
  model: Model,
  id: string,
  dataSource: string,
): Promise<Either<HttpResult, object>> {
  // Error state: If the D1 database has been tweaked outside of Cloesce
  // resulting in a malformed query, exit with a 500.
  const malformedQuery = (e: any) =>
    Either.left(
      HttpResult.fail(
        500,
        `Error in hydration query, is the database out of sync with the backend?: ${e instanceof Error ? e.message : String(e)} (ErrorCode: ${RouterFailState.InvalidDatabaseQuery})`,
      ),
    );

  // Error state: If no record is found for the id, return a 404
  const missingRecord = Either.left(
    HttpResult.fail(
      404,
      `Record not found (ErrorCode: ${RouterFailState.ModelNotFound})`,
    ),
  );

  // Query DB
  let records;
  try {
    let includeTree: IncludeTree<any> | null =
      dataSource === NO_DATA_SOURCE
        ? null
        : (constructorRegistry[model.name] as any)[dataSource];

    records = await d1
      .prepare(Orm.getQuery(constructorRegistry[model.name], includeTree))
      .bind(id)
      .run();

    if (!records?.results) {
      return missingRecord;
    }
    if (records.error) {
      return malformedQuery(records.error);
    }
  } catch (e) {
    return malformedQuery(e);
  }

  // Hydrate
  const models: object[] = mapSql(
    constructorRegistry[model.name],
    records.results,
    model.data_sources[dataSource]?.tree ?? {},
  ).value as object[];

  return Either.right(models[0]);
}

/**
 * Calls a method on a model given a list of parameters.
 * @returns 500 on an uncaught client error, 200 with a result body on success
 */
async function methodDispatch(
  crud: CrudProxy,
  di: DependencyContainer,
  route: MatchedRoute,
  params: Record<string, unknown>,
): Promise<HttpResult<unknown>> {
  // Error state: Client code ran into an uncaught exception.
  const uncaughtException = (e: any) =>
    HttpResult.fail(
      500,
      `Uncaught exception in method dispatch: ${e instanceof Error ? e.message : String(e)} (ErrorCode: ${RouterFailState.UncaughtException})`,
    );

  const paramArray: any[] = [];
  for (const param of route.params) {
    if (param.name in params) {
      paramArray.push(params[param.name]);
      continue;
    }

    // Injected type
    const injected = di.get((param.cidl_type as any)["Inject"]);
    if (!injected) {
      // Error state: Injected parameters cannot be found at compile time, only at runtime.
      // If a injected reference does not exist, throw a 500.
      return HttpResult.fail(
        500,
        `An injected parameter was missing from the instance registry: ${JSON.stringify(param.cidl_type)} (ErrorCode: ${RouterFailState.MissingDependency})`,
      );
    }

    paramArray.push(injected);
  }

  // Ensure the result is always some HttpResult
  const resultWrapper = (res: any): HttpResult<unknown> => {
    const rt = route.returnType;

    if (rt === null) {
      return HttpResult.ok(200);
    }

    if (typeof rt === "object" && rt !== null && "HttpResult" in rt) {
      return res as HttpResult<unknown>;
    }

    return HttpResult.ok(200, res);
  };

  try {
    const res = await crud.invoke(route.methodName)(...paramArray);
    return resultWrapper(res);
  } catch (e) {
    return uncaughtException(e);
  }
}

/**
 * For testing purposes
 */
export const _cloesceInternal = {
  matchRoute,
  validateRequest,
  methodDispatch,
  RuntimeContainer,
};
