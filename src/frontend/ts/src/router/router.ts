import { D1Database } from "@cloudflare/workers-types/experimental/index.js";
import {
  HttpResult,
  Either,
  ModelMethod,
  left,
  CidlType,
  right,
  CloesceAst,
  isNullableType,
  Model,
  getNavigationPropertyCidlType,
  NO_DATA_SOURCE,
  CloesceApp,
  InstanceRegistry,
} from "../common.js";
import { OrmWasmExports, fromSql, loadOrmWasm } from "./wasm.js";
import { CrudContext } from "./crud.js";

/**
 * Map of model names to their respective constructor.
 *
 * The value accepted into the `cloesce` function is generated by the Cloesce compiler, and
 * is guaranteed to contain all model definitions.
 */
type ModelConstructorRegistry = Record<string, new () => any>;

/**
 * Given a request, this represents a map of each body / url  param name to
 * its actual value. Unknown, as the a request can be anything.
 */
type RequestParamMap = Record<string, unknown>;

/**
 * Meta information on the wrangler env and db bindings
 */
interface MetaWranglerEnv {
  envName: string;
  dbName: string; // TODO: support many db's
}

/**
 * Singleton instance containing the cidl, constructor registry, and wasm binary.
 * These values are guaranteed to never change throughout a workers lifetime.
 */
export class RuntimeContainer {
  private static instance: RuntimeContainer | undefined;
  private constructor(
    public readonly ast: CloesceAst,
    public readonly constructorRegistry: ModelConstructorRegistry,
    public readonly wasm: OrmWasmExports,
  ) {}

  static async init(
    ast: CloesceAst,
    constructorRegistry: ModelConstructorRegistry,
    wasm?: WebAssembly.Instance,
  ) {
    if (this.instance) return;
    const wasmAbi = await loadOrmWasm(ast, wasm);
    this.instance = new RuntimeContainer(ast, constructorRegistry, wasmAbi);
  }

  static get(): RuntimeContainer {
    return this.instance!;
  }
}

/**
 * Runtime entry point. Given a request, undergoes: routing, validating,
 * hydrating, and method dispatch.
 *
 * @returns A Response with an `HttpResult` JSON body.
 */
export async function cloesce(
  request: Request,
  env: any,
  ast: CloesceAst,
  app: CloesceApp,
  constructorRegistry: ModelConstructorRegistry,
  envMeta: MetaWranglerEnv,
  apiRoute: string,
): Promise<Response> {
  //#region Initialization
  const ir: InstanceRegistry = new Map();
  ir.set(envMeta.envName, env);
  ir.set("Request", request);

  await RuntimeContainer.init(ast, constructorRegistry);
  const d1: D1Database = env[envMeta.dbName]; // TODO: multiple dbs
  //#endregion

  //#region Global Middleware
  for (const m of app.global) {
    const res = await m(request, env, ir);
    if (res) {
      return toResponse(res);
    }
  }
  //#endregion

  //#region Match the route to a model method
  const route = matchRoute(request, ast, apiRoute);
  if (!route.ok) {
    return toResponse(route.value);
  }
  const { method, model, id } = route.value;
  //#endregion

  //#region Model Middleware
  for (const m of app.model.get(model.name) ?? []) {
    const res = await m(request, env, ir);
    if (res) {
      return toResponse(res);
    }
  }
  //#endregion

  //#region Validate request body to the model method
  const validation = await validateRequest(request, ast, model, method, id);
  if (!validation.ok) {
    return toResponse(validation.value);
  }
  const { params, dataSource } = validation.value;
  //#endregion

  //#region Method Middleware
  for (const m of app.method.get(model.name)?.get(method.name) ?? []) {
    const res = await m(request, env, ir);
    if (res) {
      return toResponse(res);
    }
  }
  //#endregion

  //#region Instantatiate the model
  const crudCtx = await (async () => {
    if (method.is_static) {
      return right(CrudContext.fromCtor(d1, constructorRegistry[model.name]));
    }

    const hydratedModel = await hydrateModel(
      constructorRegistry,
      d1,
      model,
      id!, // id must exist after matchRoute
      dataSource!, // ds must exist after validateRequest
    );

    if (!hydratedModel.ok) {
      return hydratedModel;
    }

    return right(
      CrudContext.fromInstance(
        d1,
        hydratedModel.value,
        constructorRegistry[model.name],
      ),
    );
  })();
  if (!crudCtx.ok) {
    return toResponse(crudCtx.value);
  }
  //#endregion

  return toResponse(await methodDispatch(crudCtx.value, ir, method, params));
}

/**
 * Matches a request to a method on a model.
 * @param apiRoute The route from the domain to the actual API, ie https://foo.com/route/to/api => route/to/api/
 * @returns 404 or a `MatchedRoute`
 */
function matchRoute(
  request: Request,
  ast: CloesceAst,
  apiRoute: string,
): Either<
  HttpResult,
  {
    model: Model;
    method: ModelMethod;
    id: string | null;
  }
> {
  const url = new URL(request.url);

  // Error state: We expect an exact request format, and expect that the model
  // and are apart of the CIDL
  const notFound = (e: string) =>
    left(errorState(404, `Path not found: ${e} ${url.pathname}`));

  const routeParts = url.pathname
    .slice(apiRoute.length)
    .split("/")
    .filter(Boolean);

  if (routeParts.length < 2) {
    return notFound("Expected /model/method or /model/:id/method");
  }

  // Attempt to extract from routeParts
  const modelName = routeParts[0];
  const methodName = routeParts[routeParts.length - 1];
  const id = routeParts.length === 3 ? routeParts[1] : null;

  const model = ast.models[modelName];
  if (!model) {
    return notFound(`Unknown model ${modelName}`);
  }

  const method = model.methods[methodName];
  if (!method) {
    return notFound(`Unknown method ${modelName}.${methodName}`);
  }

  if (request.method !== method.http_verb) {
    return notFound("Unmatched HTTP method");
  }

  return right({
    model,
    method,
    id,
  });
}

/**
 * Validates the request's body/search params against a ModelMethod
 * @returns 400 or a `RequestParamMap` consisting of each parameters name mapped to its value, and
 * a data source
 */
async function validateRequest(
  request: Request,
  ast: CloesceAst,
  model: Model,
  method: ModelMethod,
  id: string | null,
): Promise<
  Either<HttpResult, { params: RequestParamMap; dataSource: string | null }>
> {
  // Error state: any missing parameter, body, or malformed input will exit with 400.
  const invalidRequest = (e: string) =>
    left(errorState(400, `Invalid Request Body: ${e}`));

  if (!method.is_static && id == null) {
    return invalidRequest("Id's are required for instantiated methods.");
  }

  // Filter out any injected parameters that will not be passed
  // by the query.
  const requiredParams = method.parameters.filter(
    (p) => !(typeof p.cidl_type === "object" && "Inject" in p.cidl_type),
  );

  // Extract url or body parameters
  const url = new URL(request.url);
  let params: RequestParamMap = {};
  if (method.http_verb === "GET") {
    params = Object.fromEntries(url.searchParams.entries());
  } else {
    try {
      params = await request.json();
    } catch {
      return invalidRequest("Could not retrieve JSON body.");
    }
  }

  // Ensure all required params exist
  if (!requiredParams.every((p) => p.name in params)) {
    return invalidRequest(`Missing parameters.`);
  }

  // Validate all parameters type
  for (const p of requiredParams) {
    const value = params[p.name];
    const isPartial =
      typeof p.cidl_type !== "string" && "Partial" in p.cidl_type;

    if (!validateCidlType(ast, value, p.cidl_type, isPartial)) {
      return invalidRequest("Invalid parameters.");
    }
  }

  // Validate data source if exists
  const dataSourceParam = requiredParams.find(
    (p) => p.cidl_type === "DataSource",
  );
  const dataSource = dataSourceParam
    ? (params[dataSourceParam.name] as string)
    : null;
  if (
    dataSource &&
    dataSource !== NO_DATA_SOURCE &&
    !(dataSource in model.data_sources)
  ) {
    return invalidRequest(`Unknown data source ${dataSource}`);
  }

  return right({ params, dataSource });
}

/**
 * Queries D1 for a particular model's ID, then transforms the SQL column output into
 * an instance of a model using the provided include tree and metadata as a guide.
 * @returns 404 if no record was found for the provided ID
 * @returns 500 if the D1 database is not synced with Cloesce and yields an error
 * @returns The instantiated model on success
 */
async function hydrateModel(
  constructorRegistry: ModelConstructorRegistry,
  d1: D1Database,
  model: Model,
  id: string,
  dataSource: string,
): Promise<Either<HttpResult, object>> {
  // Error state: If the D1 database has been tweaked outside of Cloesce
  // resulting in a malformed query, exit with a 500.
  const malformedQuery = (e: any) =>
    left(
      errorState(
        500,
        `Error in hydration query, is the database out of sync with the backend?: ${e instanceof Error ? e.message : String(e)}`,
      ),
    );

  // Error state: If no record is found for the id, return a 404
  const missingRecord = left(errorState(404, "Record not found"));

  const pk = model.primary_key.name;
  const query =
    dataSource !== NO_DATA_SOURCE
      ? `SELECT * FROM "${model.name}.${dataSource}" WHERE "${model.name}.${pk}" = ?`
      : `SELECT * FROM "${model.name}" WHERE "${pk}" = ?`;

  // Query DB
  let records;
  try {
    records = await d1.prepare(query).bind(id).run();
    if (!records?.results) {
      return missingRecord;
    }
    if (records.error) {
      return malformedQuery(records.error);
    }
  } catch (e) {
    return malformedQuery(e);
  }

  // Hydrate
  const models: object[] = fromSql(
    constructorRegistry[model.name],
    records.results,
    model.data_sources[dataSource]?.tree ?? {},
  ).value as object[];

  return right(models[0]);
}

/**
 * Calls a method on a model given a list of parameters.
 * @returns 500 on an uncaught client error, 200 with a result body on success
 */
async function methodDispatch(
  crudCtx: CrudContext,
  instanceRegistry: InstanceRegistry,
  method: ModelMethod,
  params: Record<string, unknown>,
): Promise<HttpResult<unknown>> {
  // Error state: Client code ran into an uncaught exception.
  const uncaughtException = (e: any) =>
    errorState(
      500,
      `Uncaught exception in method dispatch: ${e instanceof Error ? e.message : String(e)}`,
    );

  const paramArray = [];
  for (const param of method.parameters) {
    if (params[param.name]) {
      paramArray.push(params[param.name]);
      continue;
    }

    // Injected type
    const injected = instanceRegistry.get((param.cidl_type as any)["Inject"]);
    if (!injected) {
      // Error state: Injected parameters cannot be found at compile time, only at runtime.
      // If a injected reference does not exist, throw a 500.
      return errorState(
        500,
        `An injected parameter was missing from the instance registry: ${JSON.stringify(param.cidl_type)}`,
      );
    }

    paramArray.push(injected);
  }

  // Ensure the result is always some HttpResult
  const resultWrapper = (res: any): HttpResult<unknown> => {
    const rt = method.return_type;

    if (rt === null) {
      return { ok: true, status: 200 };
    }

    if (typeof rt === "object" && rt !== null && "HttpResult" in rt) {
      return res as HttpResult<unknown>;
    }

    return { ok: true, status: 200, data: res };
  };

  try {
    const res = await crudCtx.interceptCrud(method.name)(...paramArray);
    return resultWrapper(res);
  } catch (e) {
    return uncaughtException(e);
  }
}

function validateCidlType(
  ast: CloesceAst,
  value: unknown,
  cidlType: CidlType,
  isPartial: boolean,
): boolean {
  if (value === undefined) return isPartial;

  // TODO: consequences of null checking like this? 'null' is passed in
  // as a string for GET requests
  const nullable = isNullableType(cidlType);
  if (value == null || value === "null") return nullable;

  if (nullable) {
    cidlType = (cidlType as any).Nullable; // Unwrap the nullable type
  }

  // Handle primitive string types with switch
  if (typeof cidlType === "string") {
    switch (cidlType) {
      case "Integer":
        return Number.isInteger(Number(value));
      case "Real":
        return !Number.isNaN(Number(value));
      case "DataSource":
      case "Text":
        return typeof value === "string";
      case "Blob":
        return value instanceof Blob || value instanceof ArrayBuffer;
      default:
        return false;
    }
  }

  // Handle Models
  let cidlTypeAccessor =
    "Partial" in cidlType
      ? cidlType.Partial
      : "Object" in cidlType
        ? cidlType.Object
        : undefined;

  if (cidlTypeAccessor && ast.models[cidlTypeAccessor]) {
    const model = ast.models[cidlTypeAccessor];
    if (!model || typeof value !== "object") return false;
    const valueObj = value as Record<string, unknown>;

    // Validate attributes
    if (
      !model.attributes.every((attr) =>
        validateCidlType(
          ast,
          valueObj[attr.value.name],
          attr.value.cidl_type,
          isPartial,
        ),
      )
    ) {
      return false;
    }

    // Validate navigation properties
    return model.navigation_properties.every((nav) => {
      const navValue = valueObj[nav.var_name];

      return (
        navValue == null ||
        validateCidlType(
          ast,
          navValue,
          getNavigationPropertyCidlType(nav),
          isPartial,
        )
      );
    });
  }

  // Handle Plain Old Objects
  if (cidlTypeAccessor && ast.poos[cidlTypeAccessor]) {
    const poo = ast.poos[cidlTypeAccessor];
    if (!poo || typeof value !== "object") return false;
    const valueObj = value as Record<string, unknown>;

    // Validate attributes
    if (
      !poo.attributes.every((attr) =>
        validateCidlType(ast, valueObj[attr.name], attr.cidl_type, isPartial),
      )
    ) {
      return false;
    }
  }

  if ("Array" in cidlType) {
    const arr = cidlType.Array;
    return (
      Array.isArray(value) &&
      value.every((v) => validateCidlType(ast, v, arr, isPartial))
    );
  }

  if ("HttpResult" in cidlType) {
    if (value === null) return cidlType.HttpResult === null;
    if (cidlType.HttpResult === null) return false;
    return validateCidlType(ast, value, cidlType.HttpResult, isPartial);
  }

  return false;
}

function errorState(status: number, message: string): HttpResult {
  return { ok: false, status, message };
}

function toResponse(r: HttpResult): Response {
  return new Response(JSON.stringify(r), {
    status: r.status,
    headers: { "Content-Type": "application/json" },
  });
}

/**
 * For testing purposes
 */
export const _cloesceInternal = {
  matchRoute,
  validateRequest,
  methodDispatch,
  RuntimeContainer,
};
