---
source: workers/tests/workers_tests.rs
expression: workers
---
 
        
            import { D1Database } from "@cloudflare/workers-types"
            import { modelsFromSql, match, Result } from "cloesce"
            import cidl from "./cidl.json" with { type: "json" };
            import { Horse } from './/Users/benjaminschreiber/projects/cloesce/src/e2e/src/models/models.cloesce';
import { Like } from './/Users/benjaminschreiber/projects/cloesce/src/e2e/src/models/models.cloesce';
        
        
        export interface Env {
            DB: D1Database;
        }
        
        
            const $: any = {};

            
                $.Horse = {
                    validate(obj: any): boolean {
                        if (obj.id == null || Number.isNaN(obj.id)) {return false;}
if (obj.name == null || typeof obj.name !== "string") {return false;}
if (obj.bio == undefined || typeof obj.bio !== "string") {return false;}
                        if (obj.likes == null || !Array.isArray(obj.likes) || obj.likes.some(item => (item == null || !$.Like.validate(item)))) {return false}
                        return true;
                    }
                };
            

                $.Like = {
                    validate(obj: any): boolean {
                        if (obj.id == null || Number.isNaN(obj.id)) {return false;}
if (obj.horseId1 == null || Number.isNaN(obj.horseId1)) {return false;}
if (obj.horseId2 == null || Number.isNaN(obj.horseId2)) {return false;}
                        if (obj.horse2 == null || !$.Horse.validate(obj.horse2)) {return false}
                        return true;
                    }
                };
            
        
        const router = {"foo/api": {Horse: {"<id>": {like: async (id: number, request: Request, env: Env) => {
                
                if (request.method !== "POST") {
                    return new Response(
    JSON.stringify({ ok: false, message: `validate_http: Method Not Allowed`, status: 405 }),
    { status: 405, headers: { "Content-Type": "application/json" } }
);
                }
            
                
                    let body;
                    try {
                        body = await request.json();
                    } catch {
                        return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
);
                    }
                    let {horse} = body;
                    
if ((horse == null || !$.Horse.validate(horse))) { return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
); }
horse = Object.assign(new Horse(), horse)
                
                const d1 = env.DB;
                const query = "SELECT * FROM Horse_default WHERE Horse_id = ?";
                let record;
                try {
                    record = await d1.prepare(query).bind(id).run()
                    if (!record) {
                        return new Response(
    JSON.stringify({ ok: false, message: `hydrate_model: Record not found`, status: 404 }),
    { status: 404, headers: { "Content-Type": "application/json" } }
);
                    }
                }
                catch (e) {
                    return new Response(
    JSON.stringify({ ok: false, message: `hydrate_model: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
                }
                const instance = Object.assign(new Horse(), modelsFromSql<Horse>("Horse", cidl, record.results, Horse.default)[0]);
            
                
            try {
                let dispatch = await instance.like(env.DB, horse);
                
            return new Response(
                JSON.stringify(dispatch),
                { status: dispatch.status, headers: { "Content-Type": "application/json" } }
            );
            }
            catch (e) {
                return new Response(
    JSON.stringify({ ok: false, message: `dispatch_method: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
            }
        
            },
patch: async (id: number, request: Request, env: Env) => {
                
                if (request.method !== "PATCH") {
                    return new Response(
    JSON.stringify({ ok: false, message: `validate_http: Method Not Allowed`, status: 405 }),
    { status: 405, headers: { "Content-Type": "application/json" } }
);
                }
            
                
                    let body;
                    try {
                        body = await request.json();
                    } catch {
                        return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
);
                    }
                    let {horse} = body;
                    
if ((horse == null || !$.Horse.validate(horse))) { return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
); }
horse = Object.assign(new Horse(), horse)
                
                const d1 = env.DB;
                const query = "SELECT * FROM Horse_default WHERE Horse_id = ?";
                let record;
                try {
                    record = await d1.prepare(query).bind(id).run()
                    if (!record) {
                        return new Response(
    JSON.stringify({ ok: false, message: `hydrate_model: Record not found`, status: 404 }),
    { status: 404, headers: { "Content-Type": "application/json" } }
);
                    }
                }
                catch (e) {
                    return new Response(
    JSON.stringify({ ok: false, message: `hydrate_model: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
                }
                const instance = Object.assign(new Horse(), modelsFromSql<Horse>("Horse", cidl, record.results, Horse.default)[0]);
            
                
            try {
                let dispatch = await instance.patch(env.DB, horse);
                
            return new Response(
                JSON.stringify(dispatch),
                { status: dispatch.status, headers: { "Content-Type": "application/json" } }
            );
            }
            catch (e) {
                return new Response(
    JSON.stringify({ ok: false, message: `dispatch_method: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
            }
        
            }},
divide: async (request: Request, env: Env) => {
                
                if (request.method !== "GET") {
                    return new Response(
    JSON.stringify({ ok: false, message: `validate_http: Method Not Allowed`, status: 405 }),
    { status: 405, headers: { "Content-Type": "application/json" } }
);
                }
            
                
                    const url = new URL(request.url);
                    let {a, b} = Object.fromEntries(url.searchParams.entries());
                    
if ((a == null || Number.isNaN(a))) { return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
); }
if ((b == null || Number.isNaN(b))) { return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
); }
                
                
            try {
                let dispatch = await Horse.divide(a, b);
                
            return new Response(
                JSON.stringify(dispatch),
                { status: dispatch.status, headers: { "Content-Type": "application/json" } }
            );
            }
            catch (e) {
                return new Response(
    JSON.stringify({ ok: false, message: `dispatch_method: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
            }
        
            },
get: async (request: Request, env: Env) => {
                
                if (request.method !== "GET") {
                    return new Response(
    JSON.stringify({ ok: false, message: `validate_http: Method Not Allowed`, status: 405 }),
    { status: 405, headers: { "Content-Type": "application/json" } }
);
                }
            
                
                    const url = new URL(request.url);
                    let {id} = Object.fromEntries(url.searchParams.entries());
                    
if ((id == null || Number.isNaN(id))) { return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
); }
                
                
            try {
                let dispatch = await Horse.get(env.DB, id);
                
            return new Response(
                JSON.stringify(dispatch),
                { status: dispatch.status, headers: { "Content-Type": "application/json" } }
            );
            }
            catch (e) {
                return new Response(
    JSON.stringify({ ok: false, message: `dispatch_method: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
            }
        
            },
list: async (request: Request, env: Env) => {
                
                if (request.method !== "GET") {
                    return new Response(
    JSON.stringify({ ok: false, message: `validate_http: Method Not Allowed`, status: 405 }),
    { status: 405, headers: { "Content-Type": "application/json" } }
);
                }
            
                
                
                
            try {
                let dispatch = await Horse.list(env.DB);
                
            return new Response(
                JSON.stringify(dispatch),
                { status: dispatch.status, headers: { "Content-Type": "application/json" } }
            );
            }
            catch (e) {
                return new Response(
    JSON.stringify({ ok: false, message: `dispatch_method: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
            }
        
            },
post: async (request: Request, env: Env) => {
                
                if (request.method !== "POST") {
                    return new Response(
    JSON.stringify({ ok: false, message: `validate_http: Method Not Allowed`, status: 405 }),
    { status: 405, headers: { "Content-Type": "application/json" } }
);
                }
            
                
                    let body;
                    try {
                        body = await request.json();
                    } catch {
                        return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
);
                    }
                    let {horse} = body;
                    
if ((horse == null || !$.Horse.validate(horse))) { return new Response(
    JSON.stringify({ ok: false, message: `validate_req_body: Invalid Request Body`, status: 400 }),
    { status: 400, headers: { "Content-Type": "application/json" } }
); }
horse = Object.assign(new Horse(), horse)
                
                
            try {
                let dispatch = await Horse.post(env.DB, horse);
                
            return new Response(
                JSON.stringify(dispatch),
                { status: dispatch.status, headers: { "Content-Type": "application/json" } }
            );
            }
            catch (e) {
                return new Response(
    JSON.stringify({ ok: false, message: `dispatch_method: ${e instanceof Error ? e.message : String(e)}`, status: 500 }),
    { status: 500, headers: { "Content-Type": "application/json" } }
);
            }
        
            }}}}
        
export default {
    async fetch(request: Request, env: Env, ctx: any): Promise<Response> {
        const url = new URL(request.url);
        return await match(router, url.pathname, request, env);
    }
};
