---
source: workers/tests/workers_tests.rs
expression: workers
---
 
        import { D1Database } from "@cloudflare/workers-types"

        import { Actions } from '../actions.cloesce'; 
        

        import { Dog } from '../dog.cloesce'; 
        

        import { Person } from '../person.cloesce'; 
        
        
        export interface Env { DB: D1Database }

        function match(router: any, path: string, request: Request, env: Env): Response {
            let node: any = router;
            const params: any[] = [];
            const segments = path.split("/").filter(Boolean);
            for (const segment of segments) {
                if (node[segment]) {
                    node = node[segment];
                } 
                else {
                    const paramKey = Object.keys(node).find(k => k.startsWith("<") && k.endsWith(">"));
                    if (paramKey) {
                        params.push(segment);
                        node = node[paramKey];
                    } else {
                        return new Response(
                            JSON.stringify({ error: "Route not found", path }),
                            { 
                                status: 404,
                                headers: { "Content-Type": "application/json" }
                            }
                        );
                    }
                }
            }
            if (typeof node === "function") {
                return node(...params, request, env);
            }
            return new Response(
                JSON.stringify({ error: "Route not found", path }),
                { 
                    status: 404,
                    headers: { "Content-Type": "application/json" }
                }
            );
        }
        
        
        const router = { api: {
        Actions: {
            create: async ( request: Request, env: Env) => {
                
            if (request.method !== "POST") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
            let body;
            try {
                body = await request.json();
            } catch {
                return new Response(JSON.stringify({ error: "Invalid request body" }), {
                    status: 400,
                    headers: { "Content-Type": "application/json" },
                });
            }
            
            const {payload} = body;
            
if (payload === null || payload === undefined) { throw new Error('Required parameter missing: payload');}
if (payload !== null && typeof payload !== 'string') { throw new Error('Parameter payload must be a string'); }
                
                
        return Actions.create(env.DB, payload)
        
            }
            ,

            update: async ( request: Request, env: Env) => {
                
            if (request.method !== "PUT") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
            let body;
            try {
                body = await request.json();
            } catch {
                return new Response(JSON.stringify({ error: "Invalid request body" }), {
                    status: 400,
                    headers: { "Content-Type": "application/json" },
                });
            }
            
            const {id,payload} = body;
            
if (id === null || id === undefined) { throw new Error('Required parameter missing: id');}
if (id !== null && typeof id !== 'number') { throw new Error('Parameter id must be a number'); }
if (payload !== null && typeof payload !== 'string') { throw new Error('Parameter payload must be a string'); }
                
                
        return Actions.update(env.DB, id, payload)
        
            }
            ,

            patch: async ( request: Request, env: Env) => {
                
            if (request.method !== "PATCH") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
            let body;
            try {
                body = await request.json();
            } catch {
                return new Response(JSON.stringify({ error: "Invalid request body" }), {
                    status: 400,
                    headers: { "Content-Type": "application/json" },
                });
            }
            
            const {phrase} = body;
            
if (phrase === null || phrase === undefined) { throw new Error('Required parameter missing: phrase');}
if (phrase !== null && typeof phrase !== 'string') { throw new Error('Parameter phrase must be a string'); }
                
                
        return Actions.patch(env.DB, phrase)
        
            }
            ,

            remove: async ( request: Request, env: Env) => {
                
            if (request.method !== "DELETE") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
            let body;
            try {
                body = await request.json();
            } catch {
                return new Response(JSON.stringify({ error: "Invalid request body" }), {
                    status: 400,
                    headers: { "Content-Type": "application/json" },
                });
            }
            
            const {id} = body;
            
if (id === null || id === undefined) { throw new Error('Required parameter missing: id');}
if (id !== null && typeof id !== 'number') { throw new Error('Parameter id must be a number'); }
                
                
        return Actions.remove(env.DB, id)
        
            }
            }
        

        Dog: {
            "<id>": {
            get_name: async (id: number,  request: Request, env: Env) => {
                
            if (request.method !== "GET") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
                
        const d1 = env.DB;
        const query = `SELECT * FROM Dog WHERE id = ?`;
        const record = await d1.prepare(query).bind(id).first();
        if (!record) {
            return new Response(
                JSON.stringify({ error: "Record not found" }),
                { status: 404, headers: { "Content-Type": "application/json" } }
            );
        }
        const instance: Dog = Object.assign(new Dog(), record)
        
                
        return instance.get_name(env.DB)
        
            }
            }
            ,

            "<id>": {
            get_breed: async (id: number,  request: Request, env: Env) => {
                
            if (request.method !== "GET") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
                
        const d1 = env.DB;
        const query = `SELECT * FROM Dog WHERE id = ?`;
        const record = await d1.prepare(query).bind(id).first();
        if (!record) {
            return new Response(
                JSON.stringify({ error: "Record not found" }),
                { status: 404, headers: { "Content-Type": "application/json" } }
            );
        }
        const instance: Dog = Object.assign(new Dog(), record)
        
                
        return instance.get_breed(env.DB)
        
            }
            }
            ,

            woof: async ( request: Request, env: Env) => {
                
            if (request.method !== "POST") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
            let body;
            try {
                body = await request.json();
            } catch {
                return new Response(JSON.stringify({ error: "Invalid request body" }), {
                    status: 400,
                    headers: { "Content-Type": "application/json" },
                });
            }
            
            const {phrase} = body;
            
if (phrase === null || phrase === undefined) { throw new Error('Required parameter missing: phrase');}
if (phrase !== null && typeof phrase !== 'string') { throw new Error('Parameter phrase must be a string'); }
                
                
        return Dog.woof(env.DB, phrase)
        
            }
            }
        

        Person: {
            "<id>": {
            foo: async (id: number,  request: Request, env: Env) => {
                
            if (request.method !== "GET") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
                
        const d1 = env.DB;
        const query = `SELECT * FROM Person WHERE id = ?`;
        const record = await d1.prepare(query).bind(id).first();
        if (!record) {
            return new Response(
                JSON.stringify({ error: "Record not found" }),
                { status: 404, headers: { "Content-Type": "application/json" } }
            );
        }
        const instance: Person = Object.assign(new Person(), record)
        
                
        return instance.foo(env.DB)
        
            }
            }
            ,

            speak: async ( request: Request, env: Env) => {
                
            if (request.method !== "POST") {
                return new Response("Method Not Allowed", { status: 405 });
            }
            
                
            let body;
            try {
                body = await request.json();
            } catch {
                return new Response(JSON.stringify({ error: "Invalid request body" }), {
                    status: 400,
                    headers: { "Content-Type": "application/json" },
                });
            }
            
            const {phrase} = body;
            
if (phrase === null || phrase === undefined) { throw new Error('Required parameter missing: phrase');}
if (phrase !== null && typeof phrase !== 'string') { throw new Error('Parameter phrase must be a string'); }
                
                
        return Person.speak(env.DB, phrase)
        
            }
            }
        } }
        
        
        export default {
            async fetch(request: Request, env: Env, ctx: any): Promise<Response> {
                try {
                    const url = new URL(request.url);
                    return await match(router, url.pathname, request, env);
                } catch (error: any) {
                    console.error("Internal server error:", error);
                    return new Response(JSON.stringify({ error: error?.message }), {
                        status: 500,
                        headers: { "Content-Type": "application/json" },
                    });
                }
            }
        };
