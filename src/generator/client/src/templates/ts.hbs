// GENERATED CODE. DO NOT MODIFY.
{{#each poos}}
export class {{this.name}} {
{{#each this.attributes}}
  {{name}}: {{map_cidl_type cidl_type}};
{{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);
{{#each this.attributes}}
{{#if (is_object_array cidl_type)}}
    for (let i = 0; i < res.{{name}}?.length; i++) {
      res.{{name}}[i] = {{get_object_name cidl_type}}.fromJson(res.{{name}}[i]);
    }
{{else if (is_object cidl_type)}}
    res["{{name}}"] &&= {{get_object_name cidl_type}}.fromJson(res.{{name}});
{{else if (is_blob_array cidl_type)}}
    for (let i = 0; i < res.{{name}}.length; i++) {
      res.{{name}}[i] = b64ToU8(res.{{name}}[i]);
    }
{{else if (is_blob cidl_type)}}
    res.{{name}} = b64ToU8(res.{{name}});
{{/if}}
{{/each}}
    return res;
  }
}
{{/each}}

{{#each services}}
export class {{this.name}} {
{{#each this.methods}}
  static async {{this.name}}(
{{#each this.parameters}}
{{#if (is_serializable cidl_type)}}
    {{name}}: {{map_cidl_type cidl_type}},
{{/if}}
{{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{map_cidl_type this.return_type}}>> {
    const baseUrl = new URL("{{../../domain}}/{{../name}}/{{this.name}}");
{{#unless (is_get_request this.http_verb)}}
    const payload: any = {};
{{/unless}}

{{#each this.parameters}}
{{#if (is_serializable cidl_type)}}
{{#if (is_url_param cidl_type ../http_verb)}}
    baseUrl.searchParams.append("{{name}}", String({{name}}));
{{else}}
    payload["{{name}}"] = {{name}};
{{/if}}
{{/if}}
{{/each}}

    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
{{#unless (is_get_request this.http_verb)}}
      headers: { "Content-Type": "{{get_content_type this.parameters_media}}" },
      body: requestBody({{get_media_type this.parameters_media}}, payload),
{{/unless}}
    });

    return await HttpResult.fromResponse(
      res,
      {{get_media_type this.return_media}},
{{#if (needs_constructor this.return_type)}}
      {{map_root_cidl_type this.return_type}},
{{else}}
      undefined,
{{/if}}
      {{has_array this.return_type}}
    );
  }
{{/each}}
}
{{/each}}

{{#each models}}
export class {{this.name}} {
{{#if this.primary_key}}
  {{this.primary_key.name}}: {{map_cidl_type this.primary_key.cidl_type}};
{{/if}}
{{#each this.columns}}
  {{value.name}}: {{map_cidl_type value.cidl_type}};
{{/each}}
{{#each this.navigation_properties}}
  {{var_name}}: {{get_nav_cidl_type this}}{{#if (is_one_to_one this)}} | undefined{{/if}};
{{/each}}
{{#each this.key_params}}
  {{this}}: string;
{{/each}}
{{#each this.kv_objects}}
  {{value.name}}: {{#unless (is_stream value.cidl_type)}}KValue<{{map_cidl_type value.cidl_type}}>{{else}}KValue<void>{{/unless}}{{#if list_prefix }}[]{{/if}};
{{/each}}
{{#each this.r2_objects}}
  {{var_name}}: R2Object{{#if list_prefix}}[]{{/if}};
{{/each}}

{{#each this.methods}}
  {{#if this.is_static}}static {{/if}}async {{this.name}}(
{{#each this.parameters}}
{{#if (is_serializable cidl_type)}}
    {{name}}: {{map_cidl_type cidl_type}},
{{/if}}
{{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{#unless (is_stream this.return_type)}}{{map_cidl_type this.return_type}}{{else}}ReadableStream<{{map_cidl_type this.return_type}}>{{/unless}}>> {
{{#unless this.is_static}}
    const id = [
  {{#if ../primary_key}}
      encodeURIComponent(String(this.{{../primary_key.name}})),
  {{/if}}
  {{#each ../key_params}}
      encodeURIComponent(String(this.{{this}})),
  {{/each}}
    ].join("/");
{{/unless}}
    const baseUrl = new URL(
      `{{../../domain}}/{{../name}}/{{#unless this.is_static}}${id}/{{/unless}}{{this.name}}`
    );
{{#unless (is_get_request this.http_verb)}}
    const payload: any = {};
{{/unless}}

{{#each this.parameters}}
{{#if (is_serializable cidl_type)}}
{{#if (is_url_param cidl_type ../http_verb)}}
    baseUrl.searchParams.append("{{name}}", String({{name}}));
{{else}}
    payload["{{name}}"] = {{name}};
{{/if}}
{{/if}}
{{/each}}

    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
{{#unless (is_get_request this.http_verb)}}
      headers: { "Content-Type": "{{get_content_type this.parameters_media}}" },
      body: requestBody({{get_media_type this.parameters_media}}, payload),
{{/unless}}
    });

    return await HttpResult.fromResponse(
      res,
      {{get_media_type this.return_media}},
{{#if (needs_constructor this.return_type)}}
      {{map_root_cidl_type this.return_type}},
{{else}}
      undefined,
{{/if}}
      {{has_array this.return_type}}
    );
  }
{{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);
{{#each this.navigation_properties}}
{{#if (is_one_to_one this)}}
    res["{{var_name}}"] &&= {{this.model_reference}}.fromJson(res.{{var_name}});
{{else}}
    for (let i = 0; i < res.{{var_name}}?.length; i++) {
      res.{{var_name}}[i] = {{this.model_reference}}.fromJson(res.{{var_name}}[i]);
    }
{{/if}}
{{/each}}
{{#each this.columns}}
{{#if (is_blob_array value.cidl_type)}}
    for (let i = 0; i < res.{{value.name}}.length; i++) {
      res.{{value.name}}[i] = b64ToU8(res.{{value.name}}[i]);
    }
{{else if (is_blob value.cidl_type)}}
    res.{{value.name}} = b64ToU8(res.{{value.name}});
{{/if}}
{{/each}}
    return res;
  }
}
{{/each}}

type DeepPartialInner<T> = T extends (infer U)[]
  ? DeepPartialInner<U>[]
  : T extends object
  ? { [K in keyof T]?: DeepPartialInner<T[K]> }
  : T | (null extends T ? null : never);
export type DeepPartial<T> = DeepPartialInner<T> & { __brand?: "Partial" };

export class KValue<V> {
  key!: string;
  raw: unknown | null;
  metadata: unknown | null;
  get value(): V | null {
    return this.raw as V | null;
  }
}

export enum MediaType {
  Json = "Json",
  Octet = "Octet",
}

declare const Buffer: any;
export function b64ToU8(b64: string): Uint8Array {
  if (typeof Buffer !== "undefined") {
    const buffer = Buffer.from(b64, "base64");
    return new Uint8Array(buffer);
  }
  const s = atob(b64);
  const u8 = new Uint8Array(s.length);
  for (let i = 0; i < s.length; i++) {
    u8[i] = s.charCodeAt(i);
  }
  return u8;
}

export function u8ToB64(u8: Uint8Array): string {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(u8).toString("base64");
  }
  let s = "";
  for (let i = 0; i < u8.length; i++) {
    s += String.fromCharCode(u8[i]);
  }
  return btoa(s);
}

export class R2Object {
  key!: string;
  version!: string;
  size!: number;
  etag!: string;
  httpEtag!: string;
  uploaded!: Date;
  customMetadata?: Record<string, string>;
}

function requestBody(
  mediaType: MediaType,
  data: any | string | undefined,
): BodyInit | undefined {
  switch (mediaType) {
    case MediaType.Json: {
      return JSON.stringify(data ?? {}, (_, v) => {
        if (v instanceof Uint8Array) {
          return u8ToB64(v);
        }
        return v;
      });
    }
    case MediaType.Octet: {
      return Object.values(data)[0] as BodyInit;
    }
  }
}

export class HttpResult<T = unknown> {
  public constructor(
    public ok: boolean,
    public status: number,
    public headers: Headers,
    public data?: T,
    public message?: string,
    public mediaType?: MediaType,
  ) { }

  static async fromResponse(
    response: Response,
    mediaType: MediaType,
    ctor?: any,
    array: boolean = false,
  ): Promise<HttpResult<any>> {
    if (response.status >= 400) {
      return new HttpResult(
        false,
        response.status,
        response.headers,
        undefined,
        await response.text(),
      );
    }

    function instantiate(json: any, ctor?: any) {
      switch (ctor) {
        case Date: {
          return new Date(json);
        }
        case Uint8Array: {
          return b64ToU8(json);
        }
        case undefined: {
          return json;
        }
        default: {
          return ctor.fromJson(json);
        }
      }
    }

    async function data() {
      switch (mediaType) {
        case MediaType.Json: {
          const data = await response.json();

          if (array && Array.isArray(data)) {
            for (let i = 0; i < data.length; i++) {
              data[i] = instantiate(data[i], ctor);
            }
            return data;
          }
          return instantiate(data, ctor);
        }
        case MediaType.Octet: {
          return response.body;
        }
      }
    }
    return new HttpResult(
      true,
      response.status,
      response.headers,
      await data(),
    );
  }
}