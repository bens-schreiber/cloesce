// GENERATED CODE. DO NOT MODIFY.

import { HttpResult, DeepPartial } from "cloesce/client";
{{#each poos}}
export class {{this.name}} {
  {{#each this.attributes}}
  {{name}}: {{get_cidl_type cidl_type}};
  {{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);
    {{#each this.attributes}}
      {{#if (is_object_array cidl_type)}}
    for (let i = 0; i < res.{{name}}?.length; i++) {
      res.{{name}}[i] = {{object_name cidl_type}}.fromJson(res.{{name}}[i]);
    }
      {{else if (is_object cidl_type)}}
    res["{{name}}"] &&= Object.assign(new {{object_name cidl_type}}(), res.{{name}});
      {{else if (is_blob_array cidl_type)}}
    for (let i = 0; i < res.{{name}}.length; i++) {
      res.{{name}}[i] = blobs[res.{{name}}[i].__blobIndex]; 
    }
      {{else if (is_blob cidl_type)}}
    res.{{name}} = blobs[res.{{name}}.__blobIndex];
      {{/if}}
    {{/each}}
    return res;
  }
}
{{/each}}

{{#each services}}
export class {{this.name}} {
  {{#each this.methods}}
  static async {{this.name}}(
    {{#each this.parameters}}
      {{#if (is_serializable cidl_type)}}
    {{name}}: {{get_cidl_type cidl_type}},
      {{/if}}
    {{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{get_cidl_type this.return_type}}>> {
    const baseUrl = new URL("{{../../domain}}/{{../name}}/{{this.name}}");
    {{#if (eq this.http_verb "GET")}}
      {{#each this.parameters}}
        {{#if (is_serializable cidl_type)}}
    baseUrl.searchParams.append('{{name}}', String({{name}}));
        {{/if}}
      {{/each}}
    const res = await fetchImpl(baseUrl, { method: "GET" });
    {{else}}
    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        {{#each this.parameters}}
          {{#if (is_serializable cidl_type)}}
            {{name}}{{#unless @last}}, {{/unless}}
          {{/if}}
        {{/each}}
      })
    });
    {{/if}}
    {{#if if (is_object_array this.return_type)}}
    return await HttpResult.fromResponse<{{object_name this.return_type}}>(res, {{object_name this.return_type}}, true);
    {{else if (is_object this.return_type)}}
    return await HttpResult.fromResponse<{{object_name this.return_type}}>(res, {{object_name this.return_type}}, false);
    {{else}}
    return await HttpResult.fromResponse<{{get_cidl_type this.return_type}}>(res);
    {{/if}}
    }
  {{/each}}
}
{{/each}}

{{#each models}}
export class {{this.name}} {
  {{this.primary_key.name}}: {{get_cidl_type this.primary_key.cidl_type}};
  {{#each this.attributes}}
  {{value.name}}: {{get_cidl_type value.cidl_type}};
  {{/each}}
  {{#each this.navigation_properties}}
  {{var_name}}: {{get_nav_cidl_type this}}{{#if (is_one_to_one this)}} | undefined{{/if}};
  {{/each}}

  {{#each this.methods}}
  {{#if this.is_static}}static {{/if}}async {{this.name}}(
    {{#each this.parameters}}
      {{#if (is_serializable cidl_type)}}
    {{name}}: {{get_cidl_type cidl_type}},
      {{/if}}
    {{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{get_cidl_type this.return_type}}>> {
    const baseUrl = new URL(`{{../../domain}}/{{#if this.is_static}}{{../name}}/{{this.name}}{{else}}{{../name}}/${this.{{../primary_key.name}}}/{{this.name}}{{/if}}`);
    {{#if (eq this.http_verb "GET")}}
      {{#each this.parameters}}
        {{#if (is_serializable cidl_type)}}
    baseUrl.searchParams.append('{{name}}', String({{name}}));
        {{/if}}
      {{/each}}
    const res = await fetchImpl(baseUrl, { method: "GET" });
    {{else}}
    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        {{#each this.parameters}}
          {{#if (is_serializable cidl_type)}}
            {{name}}{{#unless @last}}, {{/unless}}
          {{/if}}
        {{/each}}
      })
    });
    {{/if}}
    {{#if if (is_object_array this.return_type)}}
    return await HttpResult.fromResponse<{{object_name this.return_type}}>(res, {{object_name this.return_type}}, true);
    {{else if (is_object this.return_type)}}
    return await HttpResult.fromResponse<{{object_name this.return_type}}>(res, {{object_name this.return_type}}, false);
    {{else}}
    return await HttpResult.fromResponse<{{get_cidl_type this.return_type}}>(res);
    {{/if}}
  }
  {{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);
    {{#each this.navigation_properties}}
      {{#if (is_one_to_one this)}}
    res["{{var_name}}"] &&= Object.assign(new {{this.model_name}}(), res.{{var_name}});
      {{/if}}
    {{#if (is_many_nav this)}}
    for (let i = 0; i < res.{{var_name}}?.length; i++) {
      res.{{var_name}}[i] = {{this.model_name}}.fromJson(res.{{var_name}}[i]);
    }
      {{/if}}
    {{/each}}

    {{#each this.attributes}}
      {{#if (is_blob_array cidl_type)}}
    for (let i = 0; i < res.{{name}}.length; i++) {
      res.{{name}}[i] = blobs[res.{{name}}[i].__blobIndex]; 
    }
      {{else if (is_blob cidl_type)}}
    res.{{name}} = blobs[res.{{name}}.__blobIndex];
      {{/if}}
    {{/each}}

    return res;
  }
}
{{/each}}
