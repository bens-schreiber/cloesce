// GENERATED CODE. DO NOT MODIFY.

import { HttpResult, DeepPartial, MediaType, requestBody, b64ToU8 } from "cloesce/client";
{{#each poos}}
export class {{this.name}} {
  {{#each this.attributes}}
  {{name}}: {{map_cidl_type cidl_type}};
  {{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);
    {{#each this.attributes}}
      {{#if (is_object_array cidl_type)}}
    for (let i = 0; i < res.{{name}}?.length; i++) {
      res.{{name}}[i] = {{get_object_name cidl_type}}.fromJson(res.{{name}}[i]);
    }
      {{else if (is_object cidl_type)}}
    res["{{name}}"] &&= {{get_object_name cidl_type}}.fromJson(res.{{name}});
      {{else if (is_blob_array cidl_type)}}
    for (let i = 0; i < res.{{name}}.length; i++) {
      res.{{name}}[i] = b64ToU8(res.{{name}}[i]);
    }
      {{else if (is_blob cidl_type)}}
    res.{{name}} = b64ToU8(res.{{name}});
      {{/if}}
    {{/each}}
    return res;
  }
}
{{/each}}

{{#each services}}
export class {{this.name}} {
  {{#each this.methods}}
  static async {{this.name}}(
    {{#each this.parameters}}
      {{#if (is_serializable cidl_type)}}
    {{name}}: {{map_cidl_type cidl_type}},
      {{/if}}
    {{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{map_cidl_type this.return_type}}>> {
    const baseUrl = new URL("{{../../domain}}/{{../name}}/{{this.name}}");
    {{#unless (is_get_request this.http_verb)}}
    const payload: any = {};
    {{/unless}}

    {{#each this.parameters}}
      {{#if (is_serializable cidl_type) }}
        {{#if (is_url_param cidl_type ../http_verb)}}
    baseUrl.searchParams.append('{{name}}', String({{name}}));
        {{else}}
    payload["{{name}}"] = {{name}};
        {{/if}}
      {{/if}}
    {{/each}}

    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
      duplex: "half",
      {{#unless (is_get_request this.http_verb)}}
      headers: { "Content-Type": "{{get_content_type this.parameters_media}}" },
      body: requestBody({{get_media_type this.parameters_media}}, payload)
      {{/unless}}
    });

    return await HttpResult.fromResponse(
      res, 
      {{get_media_type this.return_media}},
    {{#if (needs_constructor this.return_type)}}
      {{map_root_cidl_type this.return_type}},
    {{else}}
      undefined,
    {{/if}}
      {{has_array this.return_type}}
    );
    }
  {{/each}}
}
{{/each}}

{{#each d1_models}}
export class {{this.name}} {
  {{this.primary_key.name}}: {{map_cidl_type this.primary_key.cidl_type}};
  {{#each this.attributes}}
  {{value.name}}: {{map_cidl_type value.cidl_type}};
  {{/each}}
  {{#each this.navigation_properties}}
  {{var_name}}: {{get_nav_cidl_type this}}{{#if (is_one_to_one this)}} | undefined{{/if}};
  {{/each}}

  {{#each this.methods}}
  {{#if this.is_static}}static {{/if}}async {{this.name}}(
    {{#each this.parameters}}
      {{#if (is_serializable cidl_type)}}
    {{name}}: {{map_cidl_type cidl_type}},
      {{/if}}
    {{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{map_cidl_type this.return_type}}>> {
    const baseUrl = new URL(`{{../../domain}}/{{#if this.is_static}}{{../name}}/{{this.name}}{{else}}{{../name}}/${this.{{../primary_key.name}}}/{{this.name}}{{/if}}`);
    {{#unless (is_get_request this.http_verb)}}
    const payload: any = {};
    {{/unless}}

    {{#each this.parameters}}
      {{#if (is_serializable cidl_type) }}
        {{#if (is_url_param cidl_type ../http_verb)}}
    baseUrl.searchParams.append('{{name}}', String({{name}}));
        {{else}}
    payload["{{name}}"] = {{name}};
        {{/if}}
      {{/if}}
    {{/each}}

    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
      duplex: "half",
      {{#unless (is_get_request this.http_verb)}}
      headers: { "Content-Type": "{{get_content_type this.parameters_media}}" },
      body: requestBody({{get_media_type this.parameters_media}}, payload)
      {{/unless}}
    });

    return await HttpResult.fromResponse(
      res, 
      {{get_media_type this.return_media}},
    {{#if (needs_constructor this.return_type)}}
      {{map_root_cidl_type this.return_type}},
    {{else}}
      undefined,
    {{/if}}
      {{has_array this.return_type}}
    );
  }
  {{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);
    {{#each this.navigation_properties}}
      {{#if (is_one_to_one this)}}
    res["{{var_name}}"] &&= {{this.model_name}}.fromJson(res.{{var_name}});
      {{/if}}
    {{#if (is_many_nav this)}}
    for (let i = 0; i < res.{{var_name}}?.length; i++) {
      res.{{var_name}}[i] = {{this.model_name}}.fromJson(res.{{var_name}}[i]);
    }
      {{/if}}
    {{/each}}
    {{#each this.attributes}}
      {{#if (is_blob_array value.cidl_type)}}
    for (let i = 0; i < res.{{name}}.length; i++) {
      res.{{value.name}}[i] = b64ToU8(res.{{value.name}}[i]);
    }
      {{else if (is_blob value.cidl_type)}}
    res.{{value.name}} = b64ToU8(res.{{value.name}});
      {{/if}}
    {{/each}}
    return res;
  }
}
{{/each}}

{{#each kv_models}}
export class {{this.name}} {
  key: string;
  {{#unless (is_stream this.cidl_type)}}value: {{map_cidl_type this.cidl_type}};{{/unless}}
  metadata: unknown;

  {{#each this.methods}}
  {{#if this.is_static}}static {{/if}}async {{this.name}}(
    {{#each this.parameters}}
      {{#if (is_serializable cidl_type)}}
    {{name}}: {{map_cidl_type cidl_type}},
      {{/if}}
    {{/each}}
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<{{map_cidl_type this.return_type}}>> {
    const baseUrl = new URL(`{{../../domain}}/{{#if this.is_static}}{{../name}}/{{this.name}}{{else}}{{../name}}/${this.key}/{{this.name}}{{/if}}`);
    {{#unless (is_get_request this.http_verb)}}
    const payload: any = {};
    {{/unless}}

    {{#each this.parameters}}
      {{#if (is_serializable cidl_type) }}
        {{#if (is_url_param cidl_type ../http_verb)}}
    baseUrl.searchParams.append('{{name}}', String({{name}}));
        {{else}}
    payload["{{name}}"] = {{name}};
        {{/if}}
      {{/if}}
    {{/each}}

    const res = await fetchImpl(baseUrl, {
      method: "{{this.http_verb}}",
      duplex: "half",
      {{#unless (is_get_request this.http_verb)}}
      headers: { "Content-Type": "{{get_content_type this.parameters_media}}" },
      body: requestBody({{get_media_type this.parameters_media}}, payload)
      {{/unless}}
    });

    return await HttpResult.fromResponse(
      res, 
      {{get_media_type this.return_media}},
    {{#if (needs_constructor this.return_type)}}
      {{map_root_cidl_type this.return_type}},
    {{else}}
      undefined,
    {{/if}}
      {{has_array this.return_type}}
    );
  }
  {{/each}}

  static fromJson(data: any): {{this.name}} {
    const res = Object.assign(new {{this.name}}(), data);

    {{#if (is_object_array this.cidl_type)}}
    for (let i = 0; i < res.{{name}}?.length; i++) {
      res.{{name}}[i] = {{get_object_name this.cidl_type}}.fromJson(res.{{name}}[i]);
    }
    {{else if (is_object this.cidl_type)}}
    res["{{name}}"] &&= {{get_object_name this.cidl_type}}.fromJson(res.{{name}});
    {{else if (is_blob_array this.cidl_type)}}
    for (let i = 0; i < res.{{name}}.length; i++) {
      res.{{name}}[i] = b64ToU8(res.{{name}}[i]);
    }
    {{else if (is_blob cidl_type)}}
    res.{{name}} = b64ToU8(res.{{name}});
    {{/if}}

    return res;
  }
}
{{/each}}