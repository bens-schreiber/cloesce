---
source: client/tests/snaphot_tests.rs
expression: client_code
---
// GENERATED CODE. DO NOT MODIFY.
export class BasicPoo {
  field1: string;
  field2: number;

  static fromJson(data: any): BasicPoo {
    const res = Object.assign(new BasicPoo(), data);
    return res;
  }
}
export class PooWithComposition {
  field1: BasicPoo;
  field2: BasicModel;

  static fromJson(data: any): PooWithComposition {
    const res = Object.assign(new PooWithComposition(), data);
    res["field1"] &&= BasicPoo.fromJson(res.field1);
    res["field2"] &&= BasicModel.fromJson(res.field2);
    return res;
  }
}

export class BasicService {
  static async downloadData(
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<Response>> {
    const baseUrl = new URL("http://example.com/api/BasicService/downloadData");


    const res = await fetchImpl(baseUrl, {
      method: "GET",
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Octet,
      Uint8Array,
      false
    );
  }
  static async instanceMethod(
    input: number,
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<number>> {
    const baseUrl = new URL("http://example.com/api/BasicService/instanceMethod");
    const payload: any = {};

    payload["input"] = input;

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: requestBody(MediaType.Json, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }
  static async staticMethod(
    input: string,
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<string>> {
    const baseUrl = new URL("http://example.com/api/BasicService/staticMethod");

    baseUrl.searchParams.append("input", String(input));

    const res = await fetchImpl(baseUrl, {
      method: "GET",
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }
  static async uploadData(
    data: Uint8Array,
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<boolean>> {
    const baseUrl = new URL("http://example.com/api/BasicService/uploadData");
    const payload: any = {};

    payload["data"] = data;

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/octet-stream" },
      body: requestBody(MediaType.Octet, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }
}

export class BasicModel {
  id: number;
  fk_to_model: number;


  static fromJson(data: any): BasicModel {
    const res = Object.assign(new BasicModel(), data);
    return res;
  }
}
export class HasOneToOne {
  id: number;
  basicModelId: number;
  oneToOneNav: BasicModel | undefined;


  static fromJson(data: any): HasOneToOne {
    const res = Object.assign(new HasOneToOne(), data);
    res["oneToOneNav"] &&= BasicModel.fromJson(res.oneToOneNav);
    return res;
  }
}
export class HasSqlColumnTypes {
  id: number;
  string: string;
  integer: number;
  real: number;
  boolean: boolean;
  date: Date;
  stringNull: string | null;
  integerNull: number | null;
  realNull: number | null;
  booleanNull: boolean | null;
  dateNull: Date | null;


  static fromJson(data: any): HasSqlColumnTypes {
    const res = Object.assign(new HasSqlColumnTypes(), data);
    return res;
  }
}
export class ManyToManyModelA {
  id: number;
  manyToManyNav: ManyToManyModelB[];


  static fromJson(data: any): ManyToManyModelA {
    const res = Object.assign(new ManyToManyModelA(), data);
    for (let i = 0; i < res.manyToManyNav?.length; i++) {
      res.manyToManyNav[i] = ManyToManyModelB.fromJson(res.manyToManyNav[i]);
    }
    return res;
  }
}
export class ManyToManyModelB {
  id: number;
  manyToManyNav: ManyToManyModelA[];


  static fromJson(data: any): ManyToManyModelB {
    const res = Object.assign(new ManyToManyModelB(), data);
    for (let i = 0; i < res.manyToManyNav?.length; i++) {
      res.manyToManyNav[i] = ManyToManyModelA.fromJson(res.manyToManyNav[i]);
    }
    return res;
  }
}
export class ModelWithCruds {
  id: number;
  name: string;

  static async GET(
    id: number,
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<ModelWithCruds>> {
    const baseUrl = new URL(
      `http://example.com/api/ModelWithCruds/GET`
    );

    baseUrl.searchParams.append("id", String(id));
    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "GET",
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      ModelWithCruds,
      false
    );
  }
  static async LIST(
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<ModelWithCruds[]>> {
    const baseUrl = new URL(
      `http://example.com/api/ModelWithCruds/LIST`
    );

    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "GET",
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      ModelWithCruds,
      true
    );
  }
  static async SAVE(
    model: DeepPartial<ModelWithCruds>,
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<ModelWithCruds>> {
    const baseUrl = new URL(
      `http://example.com/api/ModelWithCruds/SAVE`
    );
    const payload: any = {};

    payload["model"] = model;
    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: requestBody(MediaType.Json, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      ModelWithCruds,
      false
    );
  }

  static fromJson(data: any): ModelWithCruds {
    const res = Object.assign(new ModelWithCruds(), data);
    return res;
  }
}
export class ModelWithKv {
  id1: string;
  id2: string;
  someValue: KValue<unknown>;
  manyValues: KValue<unknown>[];
  streamValue: KValue<void>;

  async hasKvParamAndRes(
    input: KValue<string>,
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<KValue<string>>> {
    const id = [
      encodeURIComponent(String(this.id1)),
      encodeURIComponent(String(this.id2)),
    ].join("/");
    const baseUrl = new URL(
      `http://example.com/api/ModelWithKv/${id}/hasKvParamAndRes`
    );
    const payload: any = {};

    payload["input"] = input;
    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: requestBody(MediaType.Json, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }
  async instanceMethod(
    input: string,
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<string>> {
    const id = [
      encodeURIComponent(String(this.id1)),
      encodeURIComponent(String(this.id2)),
    ].join("/");
    const baseUrl = new URL(
      `http://example.com/api/ModelWithKv/${id}/instanceMethod`
    );
    const payload: any = {};

    payload["input"] = input;
    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: requestBody(MediaType.Json, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }
  static async staticMethod(
    input: number,
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<number>> {
    const baseUrl = new URL(
      `http://example.com/api/ModelWithKv/staticMethod`
    );

    baseUrl.searchParams.append("input", String(input));

    const res = await fetchImpl(baseUrl, {
      method: "GET",
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }

  static fromJson(data: any): ModelWithKv {
    const res = Object.assign(new ModelWithKv(), data);
    if (res.someValue) res.someValue = Object.assign(new KValue<unknown>(), res.someValue);
    if (res.manyValues) res.manyValues = Object.assign(new KValue<unknown>(), res.manyValues);
    
    return res;
  }
}
export class ModelWithR2 {
  id: number;
  r2Id: string;
  fileData: R2Object;
  manyFileDatas: R2Object[];

  async hasR2ParamAndRes(
    input: R2Object,
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<R2Object>> {
    const id = [
      encodeURIComponent(String(this.id)),
      encodeURIComponent(String(this.r2Id)),
    ].join("/");
    const baseUrl = new URL(
      `http://example.com/api/ModelWithR2/${id}/hasR2ParamAndRes`
    );
    const payload: any = {};

    payload["input"] = input;
    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: requestBody(MediaType.Json, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }

  static fromJson(data: any): ModelWithR2 {
    const res = Object.assign(new ModelWithR2(), data);
    return res;
  }
}
export class OneToManyModel {
  id: number;
  oneToManyNav: BasicModel[];


  static fromJson(data: any): OneToManyModel {
    const res = Object.assign(new OneToManyModel(), data);
    for (let i = 0; i < res.oneToManyNav?.length; i++) {
      res.oneToManyNav[i] = BasicModel.fromJson(res.oneToManyNav[i]);
    }
    return res;
  }
}
export class ToyotaPrius {
  id: number;
  modelYear: number;
  ownerId: string;
  vehicleId: string;
  metadata: KValue<unknown>;
  photoData: R2Object;

  async instanceMethod(
    input: string,
    __datasource: "none" = "none",
    fetchImpl: typeof fetch = fetch
  ): Promise<HttpResult<string>> {
    const id = [
      encodeURIComponent(String(this.id)),
      encodeURIComponent(String(this.ownerId)),
      encodeURIComponent(String(this.vehicleId)),
    ].join("/");
    const baseUrl = new URL(
      `http://example.com/api/ToyotaPrius/${id}/instanceMethod`
    );
    const payload: any = {};

    payload["input"] = input;
    baseUrl.searchParams.append("__datasource", String(__datasource));

    const res = await fetchImpl(baseUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: requestBody(MediaType.Json, payload),
    });

    return await HttpResult.fromResponse(
      res,
      MediaType.Json,
      undefined,
      false
    );
  }

  static fromJson(data: any): ToyotaPrius {
    const res = Object.assign(new ToyotaPrius(), data);
    if (res.metadata) res.metadata = Object.assign(new KValue<unknown>(), res.metadata);
    return res;
  }
}

type DeepPartialInner<T> = T extends (infer U)[]
  ? DeepPartialInner<U>[]
  : T extends object
  ? { [K in keyof T]?: DeepPartialInner<T[K]> }
  : T | (null extends T ? null : never);
export type DeepPartial<T> = DeepPartialInner<T> & { __brand?: "Partial" };

export class KValue<V> {
  key!: string;
  raw: unknown | null;
  metadata: unknown | null;
  get value(): V | null {
    return this.raw as V | null;
  }
}

export enum MediaType {
  Json = "Json",
  Octet = "Octet",
}

declare const Buffer: any;
export function b64ToU8(b64: string): Uint8Array {
  if (typeof Buffer !== "undefined") {
    const buffer = Buffer.from(b64, "base64");
    return new Uint8Array(buffer);
  }
  const s = atob(b64);
  const u8 = new Uint8Array(s.length);
  for (let i = 0; i < s.length; i++) {
    u8[i] = s.charCodeAt(i);
  }
  return u8;
}

export function u8ToB64(u8: Uint8Array): string {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(u8).toString("base64");
  }
  let s = "";
  for (let i = 0; i < u8.length; i++) {
    s += String.fromCharCode(u8[i]);
  }
  return btoa(s);
}

export class R2Object {
  key!: string;
  version!: string;
  size!: number;
  etag!: string;
  httpEtag!: string;
  uploaded!: Date;
  customMetadata?: Record<string, string>;
}

function requestBody(
  mediaType: MediaType,
  data: any | string | undefined,
): BodyInit | undefined {
  switch (mediaType) {
    case MediaType.Json: {
      return JSON.stringify(data ?? {}, (_, v) => {
        if (v instanceof Uint8Array) {
          return u8ToB64(v);
        }
        return v;
      });
    }
    case MediaType.Octet: {
      return Object.values(data)[0] as BodyInit;
    }
  }
}

export class HttpResult<T = unknown> {
  public constructor(
    public ok: boolean,
    public status: number,
    public headers: Headers,
    public data?: T,
    public message?: string,
    public mediaType?: MediaType,
  ) { }

  static async fromResponse(
    response: Response,
    mediaType: MediaType,
    ctor?: any,
    array: boolean = false,
  ): Promise<HttpResult<any>> {
    if (response.status >= 400) {
      return new HttpResult(
        false,
        response.status,
        response.headers,
        undefined,
        await response.text(),
      );
    }

    function instantiate(json: any, ctor?: any) {
      switch (ctor) {
        case Date: {
          return new Date(json);
        }
        case Uint8Array: {
          return b64ToU8(json);
        }
        case undefined: {
          return json;
        }
        default: {
          return ctor.fromJson(json);
        }
      }
    }

    async function data() {
      switch (mediaType) {
        case MediaType.Json: {
          const data = await response.json();

          if (array && Array.isArray(data)) {
            for (let i = 0; i < data.length; i++) {
              data[i] = instantiate(data[i], ctor);
            }
            return data;
          }
          return instantiate(data, ctor);
        }
        case MediaType.Octet: {
          return response;
        }
      }
    }
    return new HttpResult(
      true,
      response.status,
      response.headers,
      await data(),
    );
  }
}
