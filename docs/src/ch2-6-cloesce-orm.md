# Cloesce ORM

> *Note*: The ORM is subject to change as new features are added.

During the hydration step of the Cloesce runtime, all of a Models data is fetched from it's various defined sources (D1, KV, R2) and combined into a single object instance. This unified object can then be used seamlessly within your application code. Luckily for developers, Cloesce doesn't keep this functionality a secret â€” it is made available through the Cloesce ORM.

## Getting and Listing Models

Cloesce provides two basic methods to select a Model from D1, KV and R2:

```typescript
import { Orm } from "cloesce/backend";
import { User } from "@data"

const orm = Orm.fromEnv(env);
const user = await orm.get(User, {
    id: 1,
    keyParams: {
        myParam: "value"
    },
    includeTree: User.withFriends
});
// => User | undefined

const users = await orm.list(User, User.withFriends);
// => User[]
```

Note that the `get` method requires the primary key of the Model to be passed in, along with any key parameters needed to construct KV or R2 keys. The `list` method simply takes an optional Include Tree to specify which navigation properties to include. This means that the `list` method cannot be used with Models that require key parameters for KV or R2 properties.

### Select, Map and Hydrate

Typically, when using D1, you require more advanced filtering capabilities. Unlike other ORMs, Cloesce admits defeat early and does not attempt to create its own query language-- SQL is king. Instead, it exposes two primitives: `select` and `map`.

The `select` method generates the appropriate SQL query to fetch the desired data from D1, generating the necessary joins for navigation properties based on the provided Include Tree. An example output of the `select` method proves it is more powerful than it may first seem.

Assume we are given a Model `Boss` who has many `Person`, and each `Person` has many `Dog` and many `Cat`. Given an Include Tree that specifies we want to include `persons`, `persons.dogs`, and `persons.cats`, the generated SQL would look like this:

```sql
SELECT 
    "Boss"."id" AS "id",
    "Person_1"."id" AS "persons.id",
    "Person_1"."bossId" AS "persons.bossId",
    "Dog_2"."id" AS "persons.dogs.id",
    "Dog_2"."personId" AS "persons.dogs.personId",
    "Cat_3"."id" AS "persons.cats.id",
    "Cat_3"."personId" AS "persons.cats.personId"
FROM "Boss"
LEFT JOIN "Person" AS "Person_1" 
    ON "Boss"."id" = "Person_1"."bossId"
LEFT JOIN "Dog" AS "Dog_2" 
    ON "Person_1"."id" = "Dog_2"."personId"
LEFT JOIN "Cat" AS "Cat_3" 
    ON "Person_1"."id" = "Cat_3"."personId"
```

`select` will generate SQL aliased as if it were a normal object graph, allowing for queries like this to work:

```typescript
const selectSql = Orm.select(User, {
    includeTree: Boss.withAll
});

const query = `
    WITH BossCte AS (
        ${selectSql}
    )
    SELECT * FROM BossCte WHERE
        [persons.dogs.id] = 5
    AND
        [persons.cat.id] = 10
    AND
        [persons.id] = 15
`
```

This SQL can be executed on a D1 instance, and the results passed to the `map` method to convert the flat result set into JSON objects:

```typescript
const results = await d1.prepare(query).all();
const bosses = Orm.map(Boss, results, Boss.withAll);
// => Boss[]
```

Finally, the `hydrate` method can be used to take these JSON objects and convert them into fully fledged Model instances, with KV and R2 properties fetched and populated:

```typescript
const orm = Orm.fromEnv(env);
const hydratedBosses = await orm.hydrate(Boss, {
    base: bosses,
    keyParams: {...},
    includeTree: Boss.withAll
});
// => Boss[]
```

> *Note*: `Orm.map` requires the input results to be in the exact format generated by `Orm.select`. Mixing and matching with other SQL queries may fail.


## Saving a Model

Cloesce combines posting and editing a Model into a single method `upsert`. Upsert is capable of creating or inserting complex object graphs including D1 and KV properties. R2 properties are not supported for upsert since they typically involve large binary data that is better handled separately.

```typescript
import { Orm } from "cloesce/backend";
import { User } from "@data"
const orm = Orm.fromEnv(env);
const result = await orm.upsert(User, {
    // id: 1, Assume User.id is an integer, we can auto-increment it
    name: "New User",
    friends: [
        {
            // Again assume Friend.id is an integer
            name: "Friend 1"
        },
        {
            id: 1, // Existing Friend
            name: "My Best Friend" // Update existing Friend name
        },
    ]
}, User.withFriends);
```

Upsert would then return the newly created User instance, complete with assigned primary keys and any navigation properties specified in the Include Tree, along with the newly created Friends.